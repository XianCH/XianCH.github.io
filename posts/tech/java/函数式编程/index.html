<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>java函数式编程思想 | X14n&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="//查询未成年作家的评分在70以上的书籍 由于洋流影响所以作家和书籍可能出现重复，需要进行去重 List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); Set&lt;Book&gt; uniqueBookValues = new HashSet&lt;&gt;(); Set&lt;Author&gt; uniqueAuthorValues = new HashSet&lt;&gt;(); for (Author author : authors) { if (uniqueAuthorValues.add(author)) { if (author.getAge() &lt; 18) { List&lt;Book&gt; books = author.getBooks(); for (Book book : books) { if (book.getScore() &gt; 70) { if (uniqueBookValues.add(book)) { bookList.add(book); } } } } } } System.out.println(bookList); List&lt;Book&gt; collect = authors.stream() .distinct() .filter(author -&gt; author.getAge() &lt; 18) .map(author -&gt; author.getBooks()) .flatMap(Collection::stream) .filter(book -&gt; book.getScore() &gt; 70) .distinct() .collect(Collectors.toList()); System.out.println(collect); 1.2 函数式编程思想 1.2.1 概念 ​ 面向对象思">
<meta name="author" content="x14n">
<link rel="canonical" href="https://XianCH.github.io/posts/tech/java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://XianCH.github.io/img/favicon.icon">
<link rel="icon" type="image/png" sizes="16x16" href="https://XianCH.github.io/img/main.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://XianCH.github.io/img/main.png">
<link rel="apple-touch-icon" href="https://XianCH.github.io/img/main.png">
<link rel="mask-icon" href="https://XianCH.github.io/img/main.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://XianCH.github.io/posts/tech/java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script defer src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

  

<meta property="og:title" content="java函数式编程思想" />
<meta property="og:description" content="//查询未成年作家的评分在70以上的书籍 由于洋流影响所以作家和书籍可能出现重复，需要进行去重 List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); Set&lt;Book&gt; uniqueBookValues = new HashSet&lt;&gt;(); Set&lt;Author&gt; uniqueAuthorValues = new HashSet&lt;&gt;(); for (Author author : authors) { if (uniqueAuthorValues.add(author)) { if (author.getAge() &lt; 18) { List&lt;Book&gt; books = author.getBooks(); for (Book book : books) { if (book.getScore() &gt; 70) { if (uniqueBookValues.add(book)) { bookList.add(book); } } } } } } System.out.println(bookList); List&lt;Book&gt; collect = authors.stream() .distinct() .filter(author -&gt; author.getAge() &lt; 18) .map(author -&gt; author.getBooks()) .flatMap(Collection::stream) .filter(book -&gt; book.getScore() &gt; 70) .distinct() .collect(Collectors.toList()); System.out.println(collect); 1.2 函数式编程思想 1.2.1 概念 ​ 面向对象思" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://XianCH.github.io/posts/tech/java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" />
<meta property="og:image" content="https://XianCH.github.io/postsImg/function.jpg" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-25T10:16:51+00:00" />
<meta property="article:modified_time" content="2023-09-22T10:16:51+00:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://XianCH.github.io/postsImg/function.jpg" />
<meta name="twitter:title" content="java函数式编程思想"/>
<meta name="twitter:description" content="//查询未成年作家的评分在70以上的书籍 由于洋流影响所以作家和书籍可能出现重复，需要进行去重 List&lt;Book&gt; bookList = new ArrayList&lt;&gt;(); Set&lt;Book&gt; uniqueBookValues = new HashSet&lt;&gt;(); Set&lt;Author&gt; uniqueAuthorValues = new HashSet&lt;&gt;(); for (Author author : authors) { if (uniqueAuthorValues.add(author)) { if (author.getAge() &lt; 18) { List&lt;Book&gt; books = author.getBooks(); for (Book book : books) { if (book.getScore() &gt; 70) { if (uniqueBookValues.add(book)) { bookList.add(book); } } } } } } System.out.println(bookList); List&lt;Book&gt; collect = authors.stream() .distinct() .filter(author -&gt; author.getAge() &lt; 18) .map(author -&gt; author.getBooks()) .flatMap(Collection::stream) .filter(book -&gt; book.getScore() &gt; 70) .distinct() .collect(Collectors.toList()); System.out.println(collect); 1.2 函数式编程思想 1.2.1 概念 ​ 面向对象思"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  1 ,
          "name": "📚文章",
          "item": "https://XianCH.github.io/posts/"
        },

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "👨🏻‍💻 技术",
          "item": "https://XianCH.github.io/posts/tech/"
        }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "java函数式编程思想",
      "item": "https://XianCH.github.io/posts/tech/java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "java函数式编程思想",
  "name": "java函数式编程思想",
  "description": "//查询未成年作家的评分在70以上的书籍 由于洋流影响所以作家和书籍可能出现重复，需要进行去重 List\u0026lt;Book\u0026gt; bookList = new ArrayList\u0026lt;\u0026gt;(); Set\u0026lt;Book\u0026gt; uniqueBookValues = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;Author\u0026gt; uniqueAuthorValues = new HashSet\u0026lt;\u0026gt;(); for (Author author : authors) { if (uniqueAuthorValues.add(author)) { if (author.getAge() \u0026lt; 18) { List\u0026lt;Book\u0026gt; books = author.getBooks(); for (Book book : books) { if (book.getScore() \u0026gt; 70) { if (uniqueBookValues.add(book)) { bookList.add(book); } } } } } } System.out.println(bookList); List\u0026lt;Book\u0026gt; collect = authors.stream() .distinct() .filter(author -\u0026gt; author.getAge() \u0026lt; 18) .map(author -\u0026gt; author.getBooks()) .flatMap(Collection::stream) .filter(book -\u0026gt; book.getScore() \u0026gt; 70) .distinct() .collect(Collectors.toList()); System.out.println(collect); 1.2 函数式编程思想 1.2.1 概念 ​ 面向对象思",
  "keywords": [
    ""
  ],
  "articleBody": "//查询未成年作家的评分在70以上的书籍 由于洋流影响所以作家和书籍可能出现重复，需要进行去重 List\u003cBook\u003e bookList = new ArrayList\u003c\u003e(); Set\u003cBook\u003e uniqueBookValues = new HashSet\u003c\u003e(); Set\u003cAuthor\u003e uniqueAuthorValues = new HashSet\u003c\u003e(); for (Author author : authors) { if (uniqueAuthorValues.add(author)) { if (author.getAge() \u003c 18) { List\u003cBook\u003e books = author.getBooks(); for (Book book : books) { if (book.getScore() \u003e 70) { if (uniqueBookValues.add(book)) { bookList.add(book); } } } } } } System.out.println(bookList); List\u003cBook\u003e collect = authors.stream() .distinct() .filter(author -\u003e author.getAge() \u003c 18) .map(author -\u003e author.getBooks()) .flatMap(Collection::stream) .filter(book -\u003e book.getScore() \u003e 70) .distinct() .collect(Collectors.toList()); System.out.println(collect); 1.2 函数式编程思想 1.2.1 概念 ​\t面向对象思想需要关注用什么对象完成什么事情。而函数式编程思想就类似于我们数学中的函数。它主要关注的是对数据进行了什么操作。\n1.2.2 优点 代码简洁，开发快速 接近自然语言，易于理解 易于\"并发编程\" 2. Lambda表达式 2.1 概述 ​\tLambda是JDK8中一个语法糖。他可以对某些匿名内部类的写法进行简化。它是函数式编程思想的一个重要体现。让我们不用关注是什么对象。而是更关注我们对数据进行了什么操作。\n2.2 核心原则 可推导可省略\n2. 3 基本格式 (参数列表)-\u003e{代码} 例一 我们在创建线程并启动时可以使用匿名内部类的写法：\nnew Thread(new Runnable() { @Override public void run() { System.out.println(\"你知道吗 我比你想象的 更想在你身边\"); } }).start(); 可以使用Lambda的格式对其进行修改。修改后如下：\nnew Thread(()-\u003e{ System.out.println(\"你知道吗 我比你想象的 更想在你身边\"); }).start(); 例二: 现有方法定义如下，其中IntBinaryOperator是一个接口。先使用匿名内部类的写法调用该方法。\npublic static int calculateNum(IntBinaryOperator operator){ int a = 10; int b = 20; return operator.applyAsInt(a, b); } public static void main(String[] args) { int i = calculateNum(new IntBinaryOperator() { @Override public int applyAsInt(int left, int right) { return left + right; } }); System.out.println(i); } Lambda写法：\npublic static void main(String[] args) { int i = calculateNum((int left, int right)-\u003e{ return left + right; }); System.out.println(i); } 例三： 现有方法定义如下，其中IntPredicate是一个接口。先使用匿名内部类的写法调用该方法。\npublic static void printNum(IntPredicate predicate){ int[] arr = {1,2,3,4,5,6,7,8,9,10}; for (int i : arr) { if(predicate.test(i)){ System.out.println(i); } } } public static void main(String[] args) { printNum(new IntPredicate() { @Override public boolean test(int value) { return value%2==0; } }); } Lambda写法：\npublic static void main(String[] args) { printNum((int value)-\u003e { return value%2==0; }); } public static void printNum(IntPredicate predicate){ int[] arr = {1,2,3,4,5,6,7,8,9,10}; for (int i : arr) { if(predicate.test(i)){ System.out.println(i); } } } 例四： 现有方法定义如下，其中Function是一个接口。先使用匿名内部类的写法调用该方法。\npublic static \u003cR\u003e R typeConver(Function\u003cString,R\u003e function){ String str = \"1235\"; R result = function.apply(str); return result; } public static void main(String[] args) { Integer result = typeConver(new Function\u003cString, Integer\u003e() { @Override public Integer apply(String s) { return Integer.valueOf(s); } }); System.out.println(result); } Lambda写法：\nInteger result = typeConver((String s)-\u003e{ return Integer.valueOf(s); }); System.out.println(result); 例五： 现有方法定义如下，其中IntConsumer是一个接口。先使用匿名内部类的写法调用该方法。\npublic static void foreachArr(IntConsumer consumer){ int[] arr = {1,2,3,4,5,6,7,8,9,10}; for (int i : arr) { consumer.accept(i); } } public static void main(String[] args) { foreachArr(new IntConsumer() { @Override public void accept(int value) { System.out.println(value); } }); } Lambda写法：\npublic static void main(String[] args) { foreachArr((int value)-\u003e{ System.out.println(value); }); } 2.4 省略规则 参数类型可以省略 方法体只有一句代码时大括号return和唯一一句代码的分号可以省略 方法只有一个参数时小括号可以省略 以上这些规则都记不住也可以省略不记 3. Stream流 3.1 概述 ​\tJava8的Stream使用的是函数式编程模式，如同它的名字一样，它可以被用来对集合或数组进行链状流式的操作。可以更方便的让我们对集合或数组操作。\n3.2 案例数据准备 org.projectlombok lombok 1.18.16 @Data @NoArgsConstructor @AllArgsConstructor @EqualsAndHashCode//用于后期的去重使用 public class Author { //id private Long id; //姓名 private String name; //年龄 private Integer age; //简介 private String intro; //作品 private List\u003cBook\u003e books; } @Data @AllArgsConstructor @NoArgsConstructor @EqualsAndHashCode//用于后期的去重使用 public class Book { //id private Long id; //书名 private String name; //分类 private String category; //评分 private Integer score; //简介 private String intro; } private static List\u003cAuthor\u003e getAuthors() { //数据初始化 Author author = new Author(1L,\"蒙多\",33,\"一个从菜刀中明悟哲理的祖安人\",null); Author author2 = new Author(2L,\"亚拉索\",15,\"狂风也追逐不上他的思考速度\",null); Author author3 = new Author(3L,\"易\",14,\"是这个世界在限制他的思维\",null); Author author4 = new Author(3L,\"易\",14,\"是这个世界在限制他的思维\",null); //书籍列表 List\u003cBook\u003e books1 = new ArrayList\u003c\u003e(); List\u003cBook\u003e books2 = new ArrayList\u003c\u003e(); List\u003cBook\u003e books3 = new ArrayList\u003c\u003e(); books1.add(new Book(1L,\"刀的两侧是光明与黑暗\",\"哲学,爱情\",88,\"用一把刀划分了爱恨\")); books1.add(new Book(2L,\"一个人不能死在同一把刀下\",\"个人成长,爱情\",99,\"讲述如何从失败中明悟真理\")); books2.add(new Book(3L,\"那风吹不到的地方\",\"哲学\",85,\"带你用思维去领略世界的尽头\")); books2.add(new Book(3L,\"那风吹不到的地方\",\"哲学\",85,\"带你用思维去领略世界的尽头\")); books2.add(new Book(4L,\"吹或不吹\",\"爱情,个人传记\",56,\"一个哲学家的恋爱观注定很难把他所在的时代理解\")); books3.add(new Book(5L,\"你的剑就是我的剑\",\"爱情\",56,\"无法想象一个武者能对他的伴侣这么的宽容\")); books3.add(new Book(6L,\"风与剑\",\"个人传记\",100,\"两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？\")); books3.add(new Book(6L,\"风与剑\",\"个人传记\",100,\"两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？\")); author.setBooks(books1); author2.setBooks(books2); author3.setBooks(books3); author4.setBooks(books3); List\u003cAuthor\u003e authorList = new ArrayList\u003c\u003e(Arrays.asList(author,author2,author3,author4)); return authorList; } 3.3 快速入门 3.3.1 需求 ​\t我们可以调用getAuthors方法获取到作家的集合。现在需要打印所有年龄小于18的作家的名字，并且要注意去重。\n3.3.2 实现 //打印所有年龄小于18的作家的名字，并且要注意去重 List\u003cAuthor\u003e authors = getAuthors(); authors. stream()//把集合转换成流 .distinct()//先去除重复的作家 .filter(author -\u003e author.getAge()\u003c18)//筛选年龄小于18的 .forEach(author -\u003e System.out.println(author.getName()));//遍历打印名字 3.4 常用操作 3.4.1 创建流 单列集合： 集合对象.stream()\nList\u003cAuthor\u003e authors = getAuthors(); Stream\u003cAuthor\u003e stream = authors.stream(); 数组：Arrays.stream(数组) 或者使用Stream.of来创建\nInteger[] arr = {1,2,3,4,5}; Stream\u003cInteger\u003e stream = Arrays.stream(arr); Stream\u003cInteger\u003e stream2 = Stream.of(arr); 双列集合：转换成单列集合后再创建\nMap\u003cString,Integer\u003e map = new HashMap\u003c\u003e(); map.put(\"蜡笔小新\",19); map.put(\"黑子\",17); map.put(\"日向翔阳\",16); Stream\u003cMap.Entry\u003cString, Integer\u003e\u003e stream = map.entrySet().stream(); 3.4.2 中间操作 filter ​\t可以对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中。\n例如：\n​\t打印所有姓名长度大于1的作家的姓名\nList\u003cAuthor\u003e authors = getAuthors(); authors.stream() .filter(author -\u003e author.getName().length()\u003e1) .forEach(author -\u003e System.out.println(author.getName())); map ​\t可以把对流中的元素进行计算或转换。\n例如：\n​\t打印所有作家的姓名\nList\u003cAuthor\u003e authors = getAuthors(); authors .stream() .map(author -\u003e author.getName()) .forEach(name-\u003eSystem.out.println(name)); // 打印所有作家的姓名 List\u003cAuthor\u003e authors = getAuthors(); // authors.stream() // .map(author -\u003e author.getName()) // .forEach(s -\u003e System.out.println(s)); authors.stream() .map(author -\u003e author.getAge()) .map(age-\u003eage+10) .forEach(age-\u003e System.out.println(age)); distinct ​\t可以去除流中的重复元素。\n例如：\n​\t打印所有作家的姓名，并且要求其中不能有重复元素。\nList\u003cAuthor\u003e authors = getAuthors(); authors.stream() .distinct() .forEach(author -\u003e System.out.println(author.getName())); 注意：distinct方法是依赖Object的equals方法来判断是否是相同对象的。所以需要注意重写equals方法。\nsorted ​\t可以对流中的元素进行排序。\n例如：\n​\t对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。\nList\u003cAuthor\u003e authors = getAuthors(); // 对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。 authors.stream() .distinct() .sorted() .forEach(author -\u003e System.out.println(author.getAge())); List\u003cAuthor\u003e authors = getAuthors(); // 对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。 authors.stream() .distinct() .sorted((o1, o2) -\u003e o2.getAge()-o1.getAge()) .forEach(author -\u003e System.out.println(author.getAge())); 注意：如果调用空参的sorted()方法，需要流中的元素是实现了Comparable。\n​\nlimit ​\t可以设置流的最大长度，超出的部分将被抛弃。\n例如：\n​\t对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素,然后打印其中年龄最大的两个作家的姓名。\nList\u003cAuthor\u003e authors = getAuthors(); authors.stream() .distinct() .sorted() .limit(2) .forEach(author -\u003e System.out.println(author.getName())); skip ​\t跳过流中的前n个元素，返回剩下的元素\n例如：\n​\t打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。\n// 打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。 List\u003cAuthor\u003e authors = getAuthors(); authors.stream() .distinct() .sorted() .skip(1) .forEach(author -\u003e System.out.println(author.getName())); flatMap ​\tmap只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象作为流中的元素。\n例一：\n​\t打印所有书籍的名字。要求对重复的元素进行去重。\n// 打印所有书籍的名字。要求对重复的元素进行去重。 List\u003cAuthor\u003e authors = getAuthors(); authors.stream() .flatMap(author -\u003e author.getBooks().stream()) .distinct() .forEach(book -\u003e System.out.println(book.getName())); 例二：\n​\t打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情\n// 打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情 爱情 List\u003cAuthor\u003e authors = getAuthors(); authors.stream() .flatMap(author -\u003e author.getBooks().stream()) .distinct() .flatMap(book -\u003e Arrays.stream(book.getCategory().split(\",\"))) .distinct() .forEach(category-\u003e System.out.println(category)); 3.4.3 终结操作 forEach ​\t对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作。\n例子：\n​\t输出所有作家的名字\n// 输出所有作家的名字 List\u003cAuthor\u003e authors = getAuthors(); authors.stream() .map(author -\u003e author.getName()) .distinct() .forEach(name-\u003e System.out.println(name)); count ​\t可以用来获取当前流中元素的个数。\n例子：\n​\t打印这些作家的所出书籍的数目，注意删除重复元素。\n// 打印这些作家的所出书籍的数目，注意删除重复元素。 List\u003cAuthor\u003e authors = getAuthors(); long count = authors.stream() .flatMap(author -\u003e author.getBooks().stream()) .distinct() .count(); System.out.println(count); max\u0026min ​\t可以用来或者流中的最值。\n例子：\n​\t分别获取这些作家的所出书籍的最高分和最低分并打印。\n// 分别获取这些作家的所出书籍的最高分和最低分并打印。 //Stream -\u003e Stream -\u003eStream -\u003e求值 List\u003cAuthor\u003e authors = getAuthors(); Optional\u003cInteger\u003e max = authors.stream() .flatMap(author -\u003e author.getBooks().stream()) .map(book -\u003e book.getScore()) .max((score1, score2) -\u003e score1 - score2); Optional\u003cInteger\u003e min = authors.stream() .flatMap(author -\u003e author.getBooks().stream()) .map(book -\u003e book.getScore()) .min((score1, score2) -\u003e score1 - score2); System.out.println(max.get()); System.out.println(min.get()); collect ​\t把当前流转换成一个集合。\n例子：\n​\t获取一个存放所有作者名字的List集合。\n// 获取一个存放所有作者名字的List集合。 List\u003cAuthor\u003e authors = getAuthors(); List\u003cString\u003e nameList = authors.stream() .map(author -\u003e author.getName()) .collect(Collectors.toList()); System.out.println(nameList); ​\t获取一个所有书名的Set集合。\n// 获取一个所有书名的Set集合。 List\u003cAuthor\u003e authors = getAuthors(); Set\u003cBook\u003e books = authors.stream() .flatMap(author -\u003e author.getBooks().stream()) .collect(Collectors.toSet()); System.out.println(books); ​\t获取一个Map集合，map的key为作者名，value为List\n// 获取一个Map集合，map的key为作者名，value为List List\u003cAuthor\u003e authors = getAuthors(); Map\u003cString, List\u003cBook\u003e\u003e map = authors.stream() .distinct() .collect(Collectors.toMap(author -\u003e author.getName(), author -\u003e author.getBooks())); System.out.println(map); 查找与匹配 anyMatch ​\t可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。\n例子：\n​\t判断是否有年龄在29以上的作家\n// 判断是否有年龄在29以上的作家 List\u003cAuthor\u003e authors = getAuthors(); boolean flag = authors.stream() .anyMatch(author -\u003e author.getAge() \u003e 29); System.out.println(flag); allMatch ​\t可以用来判断是否都符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。\n例子：\n​\t判断是否所有的作家都是成年人\n// 判断是否所有的作家都是成年人 List\u003cAuthor\u003e authors = getAuthors(); boolean flag = authors.stream() .allMatch(author -\u003e author.getAge() \u003e= 18); System.out.println(flag); noneMatch ​\t可以判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则结果为false\n例子：\n​\t判断作家是否都没有超过100岁的。\n// 判断作家是否都没有超过100岁的。 List\u003cAuthor\u003e authors = getAuthors(); boolean b = authors.stream() .noneMatch(author -\u003e author.getAge() \u003e 100); System.out.println(b); findAny ​\t获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。\n例子：\n​\t获取任意一个年龄大于18的作家，如果存在就输出他的名字\n// 获取任意一个年龄大于18的作家，如果存在就输出他的名字 List\u003cAuthor\u003e authors = getAuthors(); Optional\u003cAuthor\u003e optionalAuthor = authors.stream() .filter(author -\u003e author.getAge()\u003e18) .findAny(); optionalAuthor.ifPresent(author -\u003e System.out.println(author.getName())); findFirst ​\t获取流中的第一个元素。\n例子：\n​\t获取一个年龄最小的作家，并输出他的姓名。\n// 获取一个年龄最小的作家，并输出他的姓名。 List\u003cAuthor\u003e authors = getAuthors(); Optional\u003cAuthor\u003e first = authors.stream() .sorted((o1, o2) -\u003e o1.getAge() - o2.getAge()) .findFirst(); first.ifPresent(author -\u003e System.out.println(author.getName())); reduce归并 ​\t对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作）\n​\treduce的作用是把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。\n​\treduce两个参数的重载形式内部的计算方式如下：\nT result = identity; for (T element : this stream) result = accumulator.apply(result, element) return result; ​\t其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算也是我们通过方法参数来确定的。\n例子：\n​\t使用reduce求所有作者年龄的和\n// 使用reduce求所有作者年龄的和 List\u003cAuthor\u003e authors = getAuthors(); Integer sum = authors.stream() .distinct() .map(author -\u003e author.getAge()) .reduce(0, (result, element) -\u003e result + element); System.out.println(sum); ​\t使用reduce求所有作者中年龄的最大值\n// 使用reduce求所有作者中年龄的最大值 List\u003cAuthor\u003e authors = getAuthors(); Integer max = authors.stream() .map(author -\u003e author.getAge()) .reduce(Integer.MIN_VALUE, (result, element) -\u003e result \u003c element ? element : result); System.out.println(max); ​\t使用reduce求所有作者中年龄的最小值\n// 使用reduce求所有作者中年龄的最小值 List\u003cAuthor\u003e authors = getAuthors(); Integer min = authors.stream() .map(author -\u003e author.getAge()) .reduce(Integer.MAX_VALUE, (result, element) -\u003e result \u003e element ? element : result); System.out.println(min); ​\treduce一个参数的重载形式内部的计算\nboolean foundAny = false; T result = null; for (T element : this stream) { if (!foundAny) { foundAny = true; result = element; } else result = accumulator.apply(result, element); } return foundAny ? Optional.of(result) : Optional.empty(); ​\t如果用一个参数的重载方法去求最小值代码如下：\n// 使用reduce求所有作者中年龄的最小值 List\u003cAuthor\u003e authors = getAuthors(); Optional\u003cInteger\u003e minOptional = authors.stream() .map(author -\u003e author.getAge()) .reduce((result, element) -\u003e result \u003e element ? element : result); minOptional.ifPresent(age-\u003e System.out.println(age)); 3.5 注意事项 惰性求值（如果没有终结操作，没有中间操作是不会得到执行的） 流是一次性的（一旦一个流对象经过一个终结操作后。这个流就不能再被使用） 不会影响原数据（我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的） 4. Optional 4.1 概述 ​\t我们在编写代码的时候出现最多的就是空指针异常。所以在很多情况下我们需要做各种非空的判断。\n​\t例如：\nAuthor author = getAuthor(); if(author!=null){ System.out.println(author.getName()); } ​\t尤其是对象中的属性还是一个对象的情况下。这种判断会更多。\n​\t而过多的判断语句会让我们的代码显得臃肿不堪。\n​\t所以在JDK8中引入了Optional,养成使用Optional的习惯后你可以写出更优雅的代码来避免空指针异常。\n​\t并且在很多函数式编程相关的API中也都用到了Optional，如果不会使用Optional也会对函数式编程的学习造成影响。\n4.2 使用 4.2.1 创建对象 ​\tOptional就好像是包装类，可以把我们的具体数据封装Optional对象内部。然后我们去使用Optional中封装好的方法操作封装进去的数据就可以非常优雅的避免空指针异常。\n​\t我们一般使用Optional的静态方法ofNullable来把数据封装成一个Optional对象。无论传入的参数是否为null都不会出现问题。\nAuthor author = getAuthor(); Optional\u003cAuthor\u003e authorOptional = Optional.ofNullable(author); ​\t你可能会觉得还要加一行代码来封装数据比较麻烦。但是如果改造下getAuthor方法，让其的返回值就是封装好的Optional的话，我们在使用时就会方便很多。\n​\t而且在实际开发中我们的数据很多是从数据库获取的。Mybatis从3.5版本可以也已经支持Optional了。我们可以直接把dao方法的返回值类型定义成Optional类型，MyBastis会自己把数据封装成Optional对象返回。封装的过程也不需要我们自己操作。\n​\t如果你确定一个对象不是空的则可以使用Optional的静态方法of来把数据封装成Optional对象。\nAuthor author = new Author(); Optional\u003cAuthor\u003e authorOptional = Optional.of(author); ​\t但是一定要注意，如果使用of的时候传入的参数必须不为null。（尝试下传入null会出现什么结果）\n​\t如果一个方法的返回值类型是Optional类型。而如果我们经判断发现某次计算得到的返回值为null，这个时候就需要把null封装成Optional对象返回。这时则可以使用Optional的静态方法empty来进行封装。\nOptional.empty() ​\n​\t所以最后你觉得哪种方式会更方便呢？ofNullable\n4.2.2 安全消费值 ​\t我们获取到一个Optional对象后肯定需要对其中的数据进行使用。这时候我们可以使用其ifPresent方法对来消费其中的值。\n​\t这个方法会判断其内封装的数据是否为空，不为空时才会执行具体的消费代码。这样使用起来就更加安全了。\n​\t例如,以下写法就优雅的避免了空指针异常。\nOptional\u003cAuthor\u003e authorOptional = Optional.ofNullable(getAuthor()); authorOptional.ifPresent(author -\u003e System.out.println(author.getName())); 4.2.3 获取值 ​\t如果我们想获取值自己进行处理可以使用get方法获取，但是不推荐。因为当Optional内部的数据为空的时候会出现异常。\n4.2.4 安全获取值 ​\t如果我们期望安全的获取值。我们不推荐使用get方法，而是使用Optional提供的以下方法。\norElseGet\n获取数据并且设置数据为空时的默认值。如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建对象作为默认值返回。\nOptional\u003cAuthor\u003e authorOptional = Optional.ofNullable(getAuthor()); Author author1 = authorOptional.orElseGet(() -\u003e new Author()); orElseThrow\n获取数据，如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建异常抛出。\nOptional\u003cAuthor\u003e authorOptional = Optional.ofNullable(getAuthor()); try { Author author = authorOptional.orElseThrow((Supplier\u003cThrowable\u003e) () -\u003e new RuntimeException(\"author为空\")); System.out.println(author.getName()); } catch (Throwable throwable) { throwable.printStackTrace(); } 4.2.5 过滤 ​\t我们可以使用filter方法对数据进行过滤。如果原本是有数据的，但是不符合判断，也会变成一个无数据的Optional对象。\nOptional\u003cAuthor\u003e authorOptional = Optional.ofNullable(getAuthor()); authorOptional.filter(author -\u003e author.getAge()\u003e100).ifPresent(author -\u003e System.out.println(author.getName())); 4.2.6 判断 ​\t我们可以使用isPresent方法进行是否存在数据的判断。如果为空返回值为false,如果不为空，返回值为true。但是这种方式并不能体现Optional的好处，更推荐使用ifPresent方法。\nOptional\u003cAuthor\u003e authorOptional = Optional.ofNullable(getAuthor()); if (authorOptional.isPresent()) { System.out.println(authorOptional.get().getName()); } 4.2.7 数据转换 ​\tOptional还提供了map可以让我们的对数据进行转换，并且转换得到的数据也还是被Optional包装好的，保证了我们的使用安全。\n例如我们想获取作家的书籍集合。\nprivate static void testMap() { Optional\u003cAuthor\u003e authorOptional = getAuthorOptional(); Optional\u003cList\u003cBook\u003e\u003e optionalBooks = authorOptional.map(author -\u003e author.getBooks()); optionalBooks.ifPresent(books -\u003e System.out.println(books)); } 5. 函数式接口 5.1 概述 ​\t只有一个抽象方法的接口我们称之为函数接口。\n​\tJDK的函数式接口都加上了**@FunctionalInterface** 注解进行标识。但是无论是否加上该注解只要接口中只有一个抽象方法，都是函数式接口。\n5.2 常见函数式接口 ​\tConsumer 消费接口\n根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数进行消费。\n​\tFunction 计算转换接口\n根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数计算或转换，把结果返回\n​\tPredicate 判断接口\n根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数条件判断，返回判断结果\n​\tSupplier 生产型接口\n根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中创建对象，把创建好的对象返回\n5.3 常用的默认方法 and\n我们在使用Predicate接口时候可能需要进行判断条件的拼接。而and方法相当于是使用\u0026\u0026来拼接两个判断条件\n例如：\n打印作家中年龄大于17并且姓名的长度大于1的作家。\nList\u003cAuthor\u003e authors = getAuthors(); Stream\u003cAuthor\u003e authorStream = authors.stream(); authorStream.filter(new Predicate\u003cAuthor\u003e() { @Override public boolean test(Author author) { return author.getAge()\u003e17; } }.and(new Predicate\u003cAuthor\u003e() { @Override public boolean test(Author author) { return author.getName().length()\u003e1; } })).forEach(author -\u003e System.out.println(author)); or\n我们在使用Predicate接口时候可能需要进行判断条件的拼接。而or方法相当于是使用||来拼接两个判断条件。\n例如：\n打印作家中年龄大于17或者姓名的长度小于2的作家。\n// 打印作家中年龄大于17或者姓名的长度小于2的作家。 List\u003cAuthor\u003e authors = getAuthors(); authors.stream() .filter(new Predicate\u003cAuthor\u003e() { @Override public boolean test(Author author) { return author.getAge()\u003e17; } }.or(new Predicate\u003cAuthor\u003e() { @Override public boolean test(Author author) { return author.getName().length()\u003c2; } })).forEach(author -\u003e System.out.println(author.getName())); negate\nPredicate接口中的方法。negate方法相当于是在判断添加前面加了个! 表示取反\n例如：\n打印作家中年龄不大于17的作家。\n// 打印作家中年龄不大于17的作家。 List\u003cAuthor\u003e authors = getAuthors(); authors.stream() .filter(new Predicate\u003cAuthor\u003e() { @Override public boolean test(Author author) { return author.getAge()\u003e17; } }.negate()).forEach(author -\u003e System.out.println(author.getAge())); 6. 方法引用 ​\t我们在使用lambda时，如果方法体中只有一个方法的调用的话（包括构造方法）,我们可以用方法引用进一步简化代码。\n6.1 推荐用法 ​\t我们在使用lambda时不需要考虑什么时候用方法引用，用哪种方法引用，方法引用的格式是什么。我们只需要在写完lambda方法发现方法体只有一行代码，并且是方法的调用时使用快捷键尝试是否能够转换成方法引用即可。\n​\t当我们方法引用使用的多了慢慢的也可以直接写出方法引用。\n6.2 基本格式 ​\t类名或者对象名::方法名\n6.3 语法详解(了解) 6.3.1 引用类的静态方法 ​\t其实就是引用类的静态方法\n格式 类名::方法名 使用前提 ​\t如果我们在重写方法的时候，方法体中只有一行代码，并且这行代码是调用了某个类的静态方法，并且我们把要重写的抽象方法中所有的参数都按照顺序传入了这个静态方法中，这个时候我们就可以引用类的静态方法。\n​\n例如：\n如下代码就可以用方法引用进行简化\nList\u003cAuthor\u003e authors = getAuthors(); Stream\u003cAuthor\u003e authorStream = authors.stream(); authorStream.map(author -\u003e author.getAge()) .map(age-\u003eString.valueOf(age)); 注意，如果我们所重写的方法是没有参数的，调用的方法也是没有参数的也相当于符合以上规则。\n优化后如下：\nList\u003cAuthor\u003e authors = getAuthors(); Stream\u003cAuthor\u003e authorStream = authors.stream(); authorStream.map(author -\u003e author.getAge()) .map(String::valueOf); 6.3.2 引用对象的实例方法 格式 对象名::方法名 使用前提 ​\t如果我们在重写方法的时候，方法体中只有一行代码，并且这行代码是调用了某个对象的成员方法，并且我们把要重写的抽象方法中所有的参数都按照顺序传入了这个成员方法中，这个时候我们就可以引用对象的实例方法\n例如：\nList\u003cAuthor\u003e authors = getAuthors(); Stream\u003cAuthor\u003e authorStream = authors.stream(); StringBuilder sb = new StringBuilder(); authorStream.map(author -\u003e author.getName()) .forEach(name-\u003esb.append(name)); 优化后：\nList\u003cAuthor\u003e authors = getAuthors(); Stream\u003cAuthor\u003e authorStream = authors.stream(); StringBuilder sb = new StringBuilder(); authorStream.map(author -\u003e author.getName()) .forEach(sb::append); 6.3.4 引用类的实例方法 格式 类名::方法名 使用前提 ​\t如果我们在重写方法的时候，方法体中只有一行代码，并且这行代码是调用了第一个参数的成员方法，并且我们把要重写的抽象方法中剩余的所有的参数都按照顺序传入了这个成员方法中，这个时候我们就可以引用类的实例方法。\n例如：\ninterface UseString{ String use(String str,int start,int length); } public static String subAuthorName(String str, UseString useString){ int start = 0; int length = 1; return useString.use(str,start,length); } public static void main(String[] args) { subAuthorName(\"三更草堂\", new UseString() { @Override public String use(String str, int start, int length) { return str.substring(start,length); } }); } 优化后如下：\npublic static void main(String[] args) { subAuthorName(\"三更草堂\", String::substring); } 6.3.5 构造器引用 ​\t如果方法体中的一行代码是构造器的话就可以使用构造器引用。\n格式 类名::new 使用前提 ​\t如果我们在重写方法的时候，方法体中只有一行代码，并且这行代码是调用了某个类的构造方法，并且我们把要重写的抽象方法中的所有的参数都按照顺序传入了这个构造方法中，这个时候我们就可以引用构造器。\n例如：\nList\u003cAuthor\u003e authors = getAuthors(); authors.stream() .map(author -\u003e author.getName()) .map(name-\u003enew StringBuilder(name)) .map(sb-\u003esb.append(\"-三更\").toString()) .forEach(str-\u003e System.out.println(str)); 优化后：\nList\u003cAuthor\u003e authors = getAuthors(); authors.stream() .map(author -\u003e author.getName()) .map(StringBuilder::new) .map(sb-\u003esb.append(\"-三更\").toString()) .forEach(str-\u003e System.out.println(str)); 7. 高级用法 基本数据类型优化 ​\t我们之前用到的很多Stream的方法由于都使用了泛型。所以涉及到的参数和返回值都是引用数据类型。\n​\t即使我们操作的是整数小数，但是实际用的都是他们的包装类。JDK5中引入的自动装箱和自动拆箱让我们在使用对应的包装类时就好像使用基本数据类型一样方便。但是你一定要知道装箱和拆箱肯定是要消耗时间的。虽然这个时间消耗很下。但是在大量的数据不断的重复装箱拆箱的时候，你就不能无视这个时间损耗了。\n​\t所以为了让我们能够对这部分的时间消耗进行优化。Stream还提供了很多专门针对基本数据类型的方法。\n​\t例如：mapToInt,mapToLong,mapToDouble,flatMapToInt,flatMapToDouble等。\nprivate static void test27() { List\u003cAuthor\u003e authors = getAuthors(); authors.stream() .map(author -\u003e author.getAge()) .map(age -\u003e age + 10) .filter(age-\u003eage\u003e18) .map(age-\u003eage+2) .forEach(System.out::println); authors.stream() .mapToInt(author -\u003e author.getAge()) .map(age -\u003e age + 10) .filter(age-\u003eage\u003e18) .map(age-\u003eage+2) .forEach(System.out::println); } 并行流 ​\t当流中有大量元素时，我们可以使用并行流去提高操作的效率。其实并行流就是把任务分配给多个线程去完全。如果我们自己去用代码实现的话其实会非常的复杂，并且要求你对并发编程有足够的理解和认识。而如果我们使用Stream的话，我们只需要修改一个方法的调用就可以使用并行流来帮我们实现，从而提高效率。\n​\tparallel方法可以把串行流转换成并行流。\nprivate static void test28() { Stream\u003cInteger\u003e stream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); Integer sum = stream.parallel() .peek(new Consumer\u003cInteger\u003e() { @Override public void accept(Integer num) { System.out.println(num+Thread.currentThread().getName()); } }) .filter(num -\u003e num \u003e 5) .reduce((result, ele) -\u003e result + ele) .get(); System.out.println(sum); } ​\t也可以通过parallelStream直接获取并行流对象。\nList\u003cAuthor\u003e authors = getAuthors(); authors.parallelStream() .map(author -\u003e author.getAge()) .map(age -\u003e age + 10) .filter(age-\u003eage\u003e18) .map(age-\u003eage+2) .forEach(System.out::println); ",
  "wordCount" : "9161",
  "inLanguage": "zh",
  "image":"https://XianCH.github.io/postsImg/function.jpg","datePublished": "2023-03-25T10:16:51Z",
  "dateModified": "2023-09-22T10:16:51Z",
  "author":[{
    "@type": "Person",
    "name": "x14n"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://XianCH.github.io/posts/tech/java/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "X14n's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://XianCH.github.io/img/favicon.icon"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://XianCH.github.io/" accesskey="h" title="x14n&#39;s Blog (Alt + H)">
            <img src="https://XianCH.github.io/img/main.png" alt="logo" aria-label="logo"
                 height="35">x14n&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://XianCH.github.io/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://XianCH.github.io/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://XianCH.github.io/posts" title="📚 文章">
                <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://XianCH.github.io/tags" title="🧩 标签">
                <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://XianCH.github.io/archives/" title="⏱️ 时间轴">
                <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://XianCH.github.io/about" title="🙋🏻‍♂️ 关于">
                <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            <div class="breadcrumbs"><a href="https://XianCH.github.io/">🏠 主页</a>&nbsp;»&nbsp;<a href="https://XianCH.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://XianCH.github.io/posts/tech/">👨🏻‍💻 技术</a></div>
            <h1 class="post-title">
                java函数式编程思想
            </h1>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-03-25
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>9161字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>19分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>x14n
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://XianCH.github.io/tags/java/" style="color: var(--secondary)!important;">Java</a>
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    <span id="post_meta_style_8">
                        <span class="fa fa-commenting-o"></span>
                        <span>
                            <script src="https://cdn.staticfile.org/twikoo//twikoo.all.min.js"></script>
                            <script>
                                let url = document.documentURI
                                
                                let dnsUrl = "https://XianCH.github.io/"
                                let urlSplit = url.split(dnsUrl)
                                let finalUrl = urlSplit[1]
                                if (finalUrl[0] !== '/') {
                                    finalUrl = '/'+finalUrl
                                }
                                twikoo.getCommentsCount({
                                    envId:  null , 
                                region:  null , 
                                urls: [ 
                                    
                                    finalUrl,
                                ],
                                    includeReply: false 
                                }).then(function (res) {
                                    let count = res[0].count
                                    const obj = document.getElementById("comment_count");
                                    obj.innerText = count
                                    
                                    
                                    
                                }).catch(function (err) {
                                    
                                    console.error(err);
                                });
                            </script>
                            <span id="comment_count"></span>
                        </span>
                    </span>
                </span>

</div>
        </header> 
<figure class="entry-cover1"><img style="zoom:;" loading="lazy" src="https://XianCH.github.io/postsImg/function.jpg" alt="">
    
</figure><aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul><ul>
                <li>
                    <a href="#12-%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e6%80%9d%e6%83%b3" aria-label="1.2 函数式编程思想">1.2 函数式编程思想</a><ul>
                        
                <li>
                    <a href="#121-%e6%a6%82%e5%bf%b5" aria-label="1.2.1 概念">1.2.1 概念</a></li>
                <li>
                    <a href="#122-%e4%bc%98%e7%82%b9" aria-label="1.2.2 优点">1.2.2 优点</a></li></ul>
                </li></ul>
                    
                <li>
                    <a href="#2-lambda%e8%a1%a8%e8%be%be%e5%bc%8f" aria-label="2. Lambda表达式">2. Lambda表达式</a><ul>
                        
                <li>
                    <a href="#21-%e6%a6%82%e8%bf%b0" aria-label="2.1 概述">2.1 概述</a></li>
                <li>
                    <a href="#22-%e6%a0%b8%e5%bf%83%e5%8e%9f%e5%88%99" aria-label="2.2 核心原则">2.2 核心原则</a></li>
                <li>
                    <a href="#2-3-%e5%9f%ba%e6%9c%ac%e6%a0%bc%e5%bc%8f" aria-label="2. 3 基本格式">2. 3 基本格式</a><ul>
                        
                <li>
                    <a href="#%e4%be%8b%e4%b8%80" aria-label="例一">例一</a></li>
                <li>
                    <a href="#%e4%be%8b%e4%ba%8c" aria-label="例二:">例二:</a></li>
                <li>
                    <a href="#%e4%be%8b%e4%b8%89" aria-label="例三：">例三：</a></li>
                <li>
                    <a href="#%e4%be%8b%e5%9b%9b" aria-label="例四：">例四：</a></li>
                <li>
                    <a href="#%e4%be%8b%e4%ba%94" aria-label="例五：">例五：</a></li></ul>
                </li>
                <li>
                    <a href="#24-%e7%9c%81%e7%95%a5%e8%a7%84%e5%88%99" aria-label="2.4 省略规则">2.4 省略规则</a></li></ul>
                </li>
                <li>
                    <a href="#3-stream%e6%b5%81" aria-label="3. Stream流">3. Stream流</a><ul>
                        
                <li>
                    <a href="#31-%e6%a6%82%e8%bf%b0" aria-label="3.1 概述">3.1 概述</a></li>
                <li>
                    <a href="#32-%e6%a1%88%e4%be%8b%e6%95%b0%e6%8d%ae%e5%87%86%e5%a4%87" aria-label="3.2 案例数据准备">3.2 案例数据准备</a></li>
                <li>
                    <a href="#33-%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8" aria-label="3.3 快速入门">3.3 快速入门</a><ul>
                        
                <li>
                    <a href="#331-%e9%9c%80%e6%b1%82" aria-label="3.3.1 需求">3.3.1 需求</a></li>
                <li>
                    <a href="#332-%e5%ae%9e%e7%8e%b0" aria-label="3.3.2 实现">3.3.2 实现</a></li></ul>
                </li>
                <li>
                    <a href="#34-%e5%b8%b8%e7%94%a8%e6%93%8d%e4%bd%9c" aria-label="3.4 常用操作">3.4 常用操作</a><ul>
                        
                <li>
                    <a href="#341-%e5%88%9b%e5%bb%ba%e6%b5%81" aria-label="3.4.1 创建流">3.4.1 创建流</a></li>
                <li>
                    <a href="#342-%e4%b8%ad%e9%97%b4%e6%93%8d%e4%bd%9c" aria-label="3.4.2 中间操作">3.4.2 中间操作</a><ul>
                        
                <li>
                    <a href="#filter" aria-label="filter">filter</a></li>
                <li>
                    <a href="#map" aria-label="map">map</a></li>
                <li>
                    <a href="#distinct" aria-label="distinct">distinct</a></li>
                <li>
                    <a href="#sorted" aria-label="sorted">sorted</a></li>
                <li>
                    <a href="#limit" aria-label="limit">limit</a></li>
                <li>
                    <a href="#skip" aria-label="skip">skip</a></li>
                <li>
                    <a href="#flatmap" aria-label="flatMap">flatMap</a></li></ul>
                </li>
                <li>
                    <a href="#343-%e7%bb%88%e7%bb%93%e6%93%8d%e4%bd%9c" aria-label="3.4.3 终结操作">3.4.3 终结操作</a><ul>
                        
                <li>
                    <a href="#foreach" aria-label="forEach">forEach</a></li>
                <li>
                    <a href="#count" aria-label="count">count</a></li>
                <li>
                    <a href="#maxmin" aria-label="max&amp;amp;min">max&amp;min</a></li>
                <li>
                    <a href="#collect" aria-label="collect">collect</a></li>
                <li>
                    <a href="#%e6%9f%a5%e6%89%be%e4%b8%8e%e5%8c%b9%e9%85%8d" aria-label="查找与匹配">查找与匹配</a><ul>
                        
                <li>
                    <a href="#anymatch" aria-label="anyMatch">anyMatch</a></li>
                <li>
                    <a href="#allmatch" aria-label="allMatch">allMatch</a></li>
                <li>
                    <a href="#nonematch" aria-label="noneMatch">noneMatch</a></li>
                <li>
                    <a href="#findany" aria-label="findAny">findAny</a></li>
                <li>
                    <a href="#findfirst" aria-label="findFirst">findFirst</a></li></ul>
                </li>
                <li>
                    <a href="#reduce%e5%bd%92%e5%b9%b6" aria-label="reduce归并">reduce归并</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#35-%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" aria-label="3.5 注意事项">3.5 注意事项</a></li></ul>
                </li>
                <li>
                    <a href="#4-optional" aria-label="4. Optional">4. Optional</a><ul>
                        
                <li>
                    <a href="#41-%e6%a6%82%e8%bf%b0" aria-label="4.1 概述">4.1 概述</a></li>
                <li>
                    <a href="#42-%e4%bd%bf%e7%94%a8" aria-label="4.2 使用">4.2 使用</a><ul>
                        
                <li>
                    <a href="#421-%e5%88%9b%e5%bb%ba%e5%af%b9%e8%b1%a1" aria-label="4.2.1 创建对象">4.2.1 创建对象</a></li>
                <li>
                    <a href="#422-%e5%ae%89%e5%85%a8%e6%b6%88%e8%b4%b9%e5%80%bc" aria-label="4.2.2 安全消费值">4.2.2 安全消费值</a></li>
                <li>
                    <a href="#423-%e8%8e%b7%e5%8f%96%e5%80%bc" aria-label="4.2.3 获取值">4.2.3 获取值</a></li>
                <li>
                    <a href="#424-%e5%ae%89%e5%85%a8%e8%8e%b7%e5%8f%96%e5%80%bc" aria-label="4.2.4 安全获取值">4.2.4 安全获取值</a></li>
                <li>
                    <a href="#425-%e8%bf%87%e6%bb%a4" aria-label="4.2.5 过滤">4.2.5 过滤</a></li>
                <li>
                    <a href="#426-%e5%88%a4%e6%96%ad" aria-label="4.2.6 判断">4.2.6 判断</a></li>
                <li>
                    <a href="#427-%e6%95%b0%e6%8d%ae%e8%bd%ac%e6%8d%a2" aria-label="4.2.7 数据转换">4.2.7 数据转换</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#5-%e5%87%bd%e6%95%b0%e5%bc%8f%e6%8e%a5%e5%8f%a3" aria-label="5. 函数式接口">5. 函数式接口</a><ul>
                        
                <li>
                    <a href="#51-%e6%a6%82%e8%bf%b0" aria-label="5.1 概述">5.1 概述</a></li>
                <li>
                    <a href="#52-%e5%b8%b8%e8%a7%81%e5%87%bd%e6%95%b0%e5%bc%8f%e6%8e%a5%e5%8f%a3" aria-label="5.2 常见函数式接口">5.2 常见函数式接口</a></li>
                <li>
                    <a href="#53-%e5%b8%b8%e7%94%a8%e7%9a%84%e9%bb%98%e8%ae%a4%e6%96%b9%e6%b3%95" aria-label="5.3 常用的默认方法">5.3 常用的默认方法</a></li></ul>
                </li>
                <li>
                    <a href="#6-%e6%96%b9%e6%b3%95%e5%bc%95%e7%94%a8" aria-label="6. 方法引用">6. 方法引用</a><ul>
                        
                <li>
                    <a href="#61-%e6%8e%a8%e8%8d%90%e7%94%a8%e6%b3%95" aria-label="6.1 推荐用法">6.1 推荐用法</a></li>
                <li>
                    <a href="#62-%e5%9f%ba%e6%9c%ac%e6%a0%bc%e5%bc%8f" aria-label="6.2 基本格式">6.2 基本格式</a></li>
                <li>
                    <a href="#63-%e8%af%ad%e6%b3%95%e8%af%a6%e8%a7%a3%e4%ba%86%e8%a7%a3" aria-label="6.3 语法详解(了解)">6.3 语法详解(了解)</a><ul>
                        
                <li>
                    <a href="#631-%e5%bc%95%e7%94%a8%e7%b1%bb%e7%9a%84%e9%9d%99%e6%80%81%e6%96%b9%e6%b3%95" aria-label="6.3.1 引用类的静态方法">6.3.1 引用类的静态方法</a><ul>
                        
                <li>
                    <a href="#%e6%a0%bc%e5%bc%8f" aria-label="格式">格式</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e5%89%8d%e6%8f%90" aria-label="使用前提">使用前提</a></li></ul>
                </li>
                <li>
                    <a href="#632-%e5%bc%95%e7%94%a8%e5%af%b9%e8%b1%a1%e7%9a%84%e5%ae%9e%e4%be%8b%e6%96%b9%e6%b3%95" aria-label="6.3.2 引用对象的实例方法">6.3.2 引用对象的实例方法</a><ul>
                        
                <li>
                    <a href="#%e6%a0%bc%e5%bc%8f-1" aria-label="格式">格式</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e5%89%8d%e6%8f%90-1" aria-label="使用前提">使用前提</a></li></ul>
                </li>
                <li>
                    <a href="#634-%e5%bc%95%e7%94%a8%e7%b1%bb%e7%9a%84%e5%ae%9e%e4%be%8b%e6%96%b9%e6%b3%95" aria-label="6.3.4 引用类的实例方法">6.3.4 引用类的实例方法</a><ul>
                        
                <li>
                    <a href="#%e6%a0%bc%e5%bc%8f-2" aria-label="格式">格式</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e5%89%8d%e6%8f%90-2" aria-label="使用前提">使用前提</a></li></ul>
                </li>
                <li>
                    <a href="#635-%e6%9e%84%e9%80%a0%e5%99%a8%e5%bc%95%e7%94%a8" aria-label="6.3.5 构造器引用">6.3.5 构造器引用</a><ul>
                        
                <li>
                    <a href="#%e6%a0%bc%e5%bc%8f-3" aria-label="格式">格式</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e5%89%8d%e6%8f%90-3" aria-label="使用前提">使用前提</a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#7-%e9%ab%98%e7%ba%a7%e7%94%a8%e6%b3%95" aria-label="7. 高级用法">7. 高级用法</a><ul>
                        
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e4%bc%98%e5%8c%96" aria-label="基本数据类型优化">基本数据类型优化</a></li>
                <li>
                    <a href="#%e5%b9%b6%e8%a1%8c%e6%b5%81" aria-label="并行流">并行流</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        if (elements) {
            activeElement = Array.from(elements).find((element) => {
                if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                    (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                    return element;
                }
            }) || activeElement

            elements.forEach(element => {
                const id = encodeURI(element.getAttribute('id')).toLowerCase();
                if (element === activeElement){
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
                } else {
                    document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
                }
            })
        }
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//查询未成年作家的评分在70以上的书籍 由于洋流影响所以作家和书籍可能出现重复，需要进行去重</span>
</span></span><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>Book<span style="color:#f92672">&gt;</span> bookList <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>Set<span style="color:#f92672">&lt;</span>Book<span style="color:#f92672">&gt;</span> uniqueBookValues <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>Set<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> uniqueAuthorValues <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (Author author : authors) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (uniqueAuthorValues.<span style="color:#a6e22e">add</span>(author)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (author.<span style="color:#a6e22e">getAge</span>() <span style="color:#f92672">&lt;</span> 18) {
</span></span><span style="display:flex;"><span>            List<span style="color:#f92672">&lt;</span>Book<span style="color:#f92672">&gt;</span> books <span style="color:#f92672">=</span> author.<span style="color:#a6e22e">getBooks</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (Book book : books) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (book.<span style="color:#a6e22e">getScore</span>() <span style="color:#f92672">&gt;</span> 70) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (uniqueBookValues.<span style="color:#a6e22e">add</span>(book)) {
</span></span><span style="display:flex;"><span>                        bookList.<span style="color:#a6e22e">add</span>(book);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(bookList);
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>Book<span style="color:#f92672">&gt;</span> collect <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">distinct</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">filter</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>() <span style="color:#f92672">&lt;</span> 18)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getBooks</span>())
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">flatMap</span>(Collection::stream)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">filter</span>(book <span style="color:#f92672">-&gt;</span> book.<span style="color:#a6e22e">getScore</span>() <span style="color:#f92672">&gt;</span> 70)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">distinct</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">collect</span>(Collectors.<span style="color:#a6e22e">toList</span>());
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(collect);
</span></span></code></pre></div><h3 id="12-函数式编程思想">1.2 函数式编程思想<a hidden class="anchor" aria-hidden="true" href="#12-函数式编程思想">#</a></h3>
<h4 id="121-概念">1.2.1 概念<a hidden class="anchor" aria-hidden="true" href="#121-概念">#</a></h4>
<p>​	面向对象思想需要关注用什么对象完成什么事情。而函数式编程思想就类似于我们数学中的函数。它主要关注的是对数据进行了什么操作。</p>
<h4 id="122-优点">1.2.2 优点<a hidden class="anchor" aria-hidden="true" href="#122-优点">#</a></h4>
<ul>
<li>代码简洁，开发快速</li>
<li>接近自然语言，易于理解</li>
<li>易于&quot;并发编程&quot;</li>
</ul>
<h2 id="2-lambda表达式">2. Lambda表达式<a hidden class="anchor" aria-hidden="true" href="#2-lambda表达式">#</a></h2>
<h3 id="21-概述">2.1 概述<a hidden class="anchor" aria-hidden="true" href="#21-概述">#</a></h3>
<p>​	Lambda是JDK8中一个语法糖。他可以对某些匿名内部类的写法进行简化。它是函数式编程思想的一个重要体现。让我们不用关注是什么对象。而是更关注我们对数据进行了什么操作。</p>
<h3 id="22-核心原则">2.2 核心原则<a hidden class="anchor" aria-hidden="true" href="#22-核心原则">#</a></h3>
<blockquote>
<p>可推导可省略</p>
</blockquote>
<h3 id="2-3-基本格式">2. 3 基本格式<a hidden class="anchor" aria-hidden="true" href="#2-3-基本格式">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>(参数列表)<span style="color:#f92672">-&gt;</span>{代码}
</span></span></code></pre></div><h4 id="例一">例一<a hidden class="anchor" aria-hidden="true" href="#例一">#</a></h4>
<p>我们在创建线程并启动时可以使用匿名内部类的写法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">new</span> Thread(<span style="color:#66d9ef">new</span> Runnable() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;你知道吗 我比你想象的 更想在你身边&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}).<span style="color:#a6e22e">start</span>();
</span></span></code></pre></div><p>可以使用Lambda的格式对其进行修改。修改后如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">new</span> Thread(()<span style="color:#f92672">-&gt;</span>{
</span></span><span style="display:flex;"><span>    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;你知道吗 我比你想象的 更想在你身边&#34;</span>);
</span></span><span style="display:flex;"><span>}).<span style="color:#a6e22e">start</span>();
</span></span></code></pre></div><h4 id="例二">例二:<a hidden class="anchor" aria-hidden="true" href="#例二">#</a></h4>
<p>现有方法定义如下，其中IntBinaryOperator是一个接口。先使用匿名内部类的写法调用该方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">calculateNum</span>(IntBinaryOperator operator){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> 10;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> 20;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> operator.<span style="color:#a6e22e">applyAsInt</span>(a, b);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> calculateNum(<span style="color:#66d9ef">new</span> IntBinaryOperator() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">applyAsInt</span>(<span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> left <span style="color:#f92672">+</span> right;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(i);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Lambda写法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> calculateNum((<span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right)<span style="color:#f92672">-&gt;</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> left <span style="color:#f92672">+</span> right;
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(i);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h4 id="例三">例三：<a hidden class="anchor" aria-hidden="true" href="#例三">#</a></h4>
<p>现有方法定义如下，其中IntPredicate是一个接口。先使用匿名内部类的写法调用该方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printNum</span>(IntPredicate predicate){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr <span style="color:#f92672">=</span> {1,2,3,4,5,6,7,8,9,10};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i : arr) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(predicate.<span style="color:#a6e22e">test</span>(i)){
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(i);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        printNum(<span style="color:#66d9ef">new</span> IntPredicate() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">test</span>(<span style="color:#66d9ef">int</span> value) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> value<span style="color:#f92672">%</span>2<span style="color:#f92672">==</span>0;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Lambda写法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        printNum((<span style="color:#66d9ef">int</span> value)<span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> value<span style="color:#f92672">%</span>2<span style="color:#f92672">==</span>0;
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printNum</span>(IntPredicate predicate){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr <span style="color:#f92672">=</span> {1,2,3,4,5,6,7,8,9,10};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i : arr) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(predicate.<span style="color:#a6e22e">test</span>(i)){
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(i);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h4 id="例四">例四：<a hidden class="anchor" aria-hidden="true" href="#例四">#</a></h4>
<p>现有方法定义如下，其中Function是一个接口。先使用匿名内部类的写法调用该方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#f92672">&lt;</span>R<span style="color:#f92672">&gt;</span> R <span style="color:#a6e22e">typeConver</span>(Function<span style="color:#f92672">&lt;</span>String,R<span style="color:#f92672">&gt;</span> function){
</span></span><span style="display:flex;"><span>        String str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1235&#34;</span>;
</span></span><span style="display:flex;"><span>        R result <span style="color:#f92672">=</span> function.<span style="color:#a6e22e">apply</span>(str);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        Integer result <span style="color:#f92672">=</span> typeConver(<span style="color:#66d9ef">new</span> Function<span style="color:#f92672">&lt;</span>String, Integer<span style="color:#f92672">&gt;</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span> Integer <span style="color:#a6e22e">apply</span>(String s) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> Integer.<span style="color:#a6e22e">valueOf</span>(s);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(result);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Lambda写法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        Integer result <span style="color:#f92672">=</span> typeConver((String s)<span style="color:#f92672">-&gt;</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Integer.<span style="color:#a6e22e">valueOf</span>(s);
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(result);
</span></span></code></pre></div><h4 id="例五">例五：<a hidden class="anchor" aria-hidden="true" href="#例五">#</a></h4>
<p>现有方法定义如下，其中IntConsumer是一个接口。先使用匿名内部类的写法调用该方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foreachArr</span>(IntConsumer consumer){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr <span style="color:#f92672">=</span> {1,2,3,4,5,6,7,8,9,10};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i : arr) {
</span></span><span style="display:flex;"><span>            consumer.<span style="color:#a6e22e">accept</span>(i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        foreachArr(<span style="color:#66d9ef">new</span> IntConsumer() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">accept</span>(<span style="color:#66d9ef">int</span> value) {
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(value);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Lambda写法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        foreachArr((<span style="color:#66d9ef">int</span> value)<span style="color:#f92672">-&gt;</span>{
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(value);
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="24-省略规则">2.4 省略规则<a hidden class="anchor" aria-hidden="true" href="#24-省略规则">#</a></h3>
<ul>
<li>参数类型可以省略</li>
<li>方法体只有一句代码时大括号return和唯一一句代码的分号可以省略</li>
<li>方法只有一个参数时小括号可以省略</li>
<li>以上这些规则都记不住也可以省略不记</li>
</ul>
<h2 id="3-stream流">3. Stream流<a hidden class="anchor" aria-hidden="true" href="#3-stream流">#</a></h2>
<h3 id="31-概述">3.1 概述<a hidden class="anchor" aria-hidden="true" href="#31-概述">#</a></h3>
<p>​	Java8的Stream使用的是函数式编程模式，如同它的名字一样，它可以被用来对集合或数组进行链状流式的操作。可以更方便的让我们对集合或数组操作。</p>
<h3 id="32-案例数据准备">3.2 案例数据准备<a hidden class="anchor" aria-hidden="true" href="#32-案例数据准备">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span>    <span style="color:#f92672">&lt;dependencies&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;dependency&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;groupId&gt;</span>org.projectlombok<span style="color:#f92672">&lt;/groupId&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;artifactId&gt;</span>lombok<span style="color:#f92672">&lt;/artifactId&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&lt;version&gt;</span>1.18.16<span style="color:#f92672">&lt;/version&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;/dependency&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;/dependencies&gt;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Data</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@NoArgsConstructor</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@AllArgsConstructor</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@EqualsAndHashCode</span><span style="color:#75715e">//用于后期的去重使用</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Author</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//id</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Long id;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//姓名</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String name;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//年龄</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Integer age;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//简介</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String intro;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//作品</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> List<span style="color:#f92672">&lt;</span>Book<span style="color:#f92672">&gt;</span> books;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Data</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@AllArgsConstructor</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@NoArgsConstructor</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@EqualsAndHashCode</span><span style="color:#75715e">//用于后期的去重使用</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Book</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//id</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Long id;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//书名</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String name;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//分类</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String category;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//评分</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Integer score;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//简介</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String intro;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">getAuthors</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//数据初始化</span>
</span></span><span style="display:flex;"><span>        Author author <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Author(1L,<span style="color:#e6db74">&#34;蒙多&#34;</span>,33,<span style="color:#e6db74">&#34;一个从菜刀中明悟哲理的祖安人&#34;</span>,<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>        Author author2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Author(2L,<span style="color:#e6db74">&#34;亚拉索&#34;</span>,15,<span style="color:#e6db74">&#34;狂风也追逐不上他的思考速度&#34;</span>,<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>        Author author3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Author(3L,<span style="color:#e6db74">&#34;易&#34;</span>,14,<span style="color:#e6db74">&#34;是这个世界在限制他的思维&#34;</span>,<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>        Author author4 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Author(3L,<span style="color:#e6db74">&#34;易&#34;</span>,14,<span style="color:#e6db74">&#34;是这个世界在限制他的思维&#34;</span>,<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//书籍列表</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Book<span style="color:#f92672">&gt;</span> books1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Book<span style="color:#f92672">&gt;</span> books2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Book<span style="color:#f92672">&gt;</span> books3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        books1.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> Book(1L,<span style="color:#e6db74">&#34;刀的两侧是光明与黑暗&#34;</span>,<span style="color:#e6db74">&#34;哲学,爱情&#34;</span>,88,<span style="color:#e6db74">&#34;用一把刀划分了爱恨&#34;</span>));
</span></span><span style="display:flex;"><span>        books1.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> Book(2L,<span style="color:#e6db74">&#34;一个人不能死在同一把刀下&#34;</span>,<span style="color:#e6db74">&#34;个人成长,爱情&#34;</span>,99,<span style="color:#e6db74">&#34;讲述如何从失败中明悟真理&#34;</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        books2.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> Book(3L,<span style="color:#e6db74">&#34;那风吹不到的地方&#34;</span>,<span style="color:#e6db74">&#34;哲学&#34;</span>,85,<span style="color:#e6db74">&#34;带你用思维去领略世界的尽头&#34;</span>));
</span></span><span style="display:flex;"><span>        books2.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> Book(3L,<span style="color:#e6db74">&#34;那风吹不到的地方&#34;</span>,<span style="color:#e6db74">&#34;哲学&#34;</span>,85,<span style="color:#e6db74">&#34;带你用思维去领略世界的尽头&#34;</span>));
</span></span><span style="display:flex;"><span>        books2.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> Book(4L,<span style="color:#e6db74">&#34;吹或不吹&#34;</span>,<span style="color:#e6db74">&#34;爱情,个人传记&#34;</span>,56,<span style="color:#e6db74">&#34;一个哲学家的恋爱观注定很难把他所在的时代理解&#34;</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        books3.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> Book(5L,<span style="color:#e6db74">&#34;你的剑就是我的剑&#34;</span>,<span style="color:#e6db74">&#34;爱情&#34;</span>,56,<span style="color:#e6db74">&#34;无法想象一个武者能对他的伴侣这么的宽容&#34;</span>));
</span></span><span style="display:flex;"><span>        books3.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> Book(6L,<span style="color:#e6db74">&#34;风与剑&#34;</span>,<span style="color:#e6db74">&#34;个人传记&#34;</span>,100,<span style="color:#e6db74">&#34;两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？&#34;</span>));
</span></span><span style="display:flex;"><span>        books3.<span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">new</span> Book(6L,<span style="color:#e6db74">&#34;风与剑&#34;</span>,<span style="color:#e6db74">&#34;个人传记&#34;</span>,100,<span style="color:#e6db74">&#34;两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？&#34;</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        author.<span style="color:#a6e22e">setBooks</span>(books1);
</span></span><span style="display:flex;"><span>        author2.<span style="color:#a6e22e">setBooks</span>(books2);
</span></span><span style="display:flex;"><span>        author3.<span style="color:#a6e22e">setBooks</span>(books3);
</span></span><span style="display:flex;"><span>        author4.<span style="color:#a6e22e">setBooks</span>(books3);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authorList <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>(Arrays.<span style="color:#a6e22e">asList</span>(author,author2,author3,author4));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> authorList;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="33-快速入门">3.3 快速入门<a hidden class="anchor" aria-hidden="true" href="#33-快速入门">#</a></h3>
<h4 id="331-需求">3.3.1 需求<a hidden class="anchor" aria-hidden="true" href="#331-需求">#</a></h4>
<p>​	我们可以调用getAuthors方法获取到作家的集合。现在需要打印所有年龄小于18的作家的名字，并且要注意去重。</p>
<h4 id="332-实现">3.3.2 实现<a hidden class="anchor" aria-hidden="true" href="#332-实现">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#75715e">//打印所有年龄小于18的作家的名字，并且要注意去重</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        authors.
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">stream</span>()<span style="color:#75715e">//把集合转换成流</span>
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">distinct</span>()<span style="color:#75715e">//先去除重复的作家</span>
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">filter</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>()<span style="color:#f92672">&lt;</span>18)<span style="color:#75715e">//筛选年龄小于18的</span>
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(author <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(author.<span style="color:#a6e22e">getName</span>()));<span style="color:#75715e">//遍历打印名字</span>
</span></span></code></pre></div><h3 id="34-常用操作">3.4 常用操作<a hidden class="anchor" aria-hidden="true" href="#34-常用操作">#</a></h3>
<h4 id="341-创建流">3.4.1 创建流<a hidden class="anchor" aria-hidden="true" href="#341-创建流">#</a></h4>
<p>单列集合： <code>集合对象.stream()</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>		Stream<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> stream <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>();
</span></span></code></pre></div><p>数组：<code>Arrays.stream(数组) </code>或者使用<code>Stream.of</code>来创建</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-JAVA" data-lang="JAVA"><span style="display:flex;"><span>        Integer<span style="color:#f92672">[]</span> arr <span style="color:#f92672">=</span> {1,2,3,4,5};
</span></span><span style="display:flex;"><span>        Stream<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> stream <span style="color:#f92672">=</span> Arrays.<span style="color:#a6e22e">stream</span>(arr);
</span></span><span style="display:flex;"><span>        Stream<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> stream2 <span style="color:#f92672">=</span> Stream.<span style="color:#a6e22e">of</span>(arr);
</span></span></code></pre></div><p>双列集合：转换成单列集合后再创建</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        Map<span style="color:#f92672">&lt;</span>String,Integer<span style="color:#f92672">&gt;</span> map <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        map.<span style="color:#a6e22e">put</span>(<span style="color:#e6db74">&#34;蜡笔小新&#34;</span>,19);
</span></span><span style="display:flex;"><span>        map.<span style="color:#a6e22e">put</span>(<span style="color:#e6db74">&#34;黑子&#34;</span>,17);
</span></span><span style="display:flex;"><span>        map.<span style="color:#a6e22e">put</span>(<span style="color:#e6db74">&#34;日向翔阳&#34;</span>,16);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Stream<span style="color:#f92672">&lt;</span>Map.<span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>String, Integer<span style="color:#f92672">&gt;&gt;</span> stream <span style="color:#f92672">=</span> map.<span style="color:#a6e22e">entrySet</span>().<span style="color:#a6e22e">stream</span>();
</span></span></code></pre></div><h4 id="342-中间操作">3.4.2 中间操作<a hidden class="anchor" aria-hidden="true" href="#342-中间操作">#</a></h4>
<h5 id="filter">filter<a hidden class="anchor" aria-hidden="true" href="#filter">#</a></h5>
<p>​	可以对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中。</p>
<p>例如：</p>
<p>​	打印所有姓名长度大于1的作家的姓名</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">filter</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getName</span>().<span style="color:#a6e22e">length</span>()<span style="color:#f92672">&gt;</span>1)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(author <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(author.<span style="color:#a6e22e">getName</span>()));
</span></span></code></pre></div><h5 id="map">map<a hidden class="anchor" aria-hidden="true" href="#map">#</a></h5>
<p>​	可以把对流中的元素进行计算或转换。</p>
<p>例如：</p>
<p>​	打印所有作家的姓名</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        authors
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getName</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(name<span style="color:#f92672">-&gt;</span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(name));
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        打印所有作家的姓名</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//        authors.stream()</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//                .map(author -&gt; author.getName())</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//                .forEach(s -&gt; System.out.println(s));</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(age<span style="color:#f92672">-&gt;</span>age<span style="color:#f92672">+</span>10)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(age<span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(age));
</span></span></code></pre></div><h5 id="distinct">distinct<a hidden class="anchor" aria-hidden="true" href="#distinct">#</a></h5>
<p>​	可以去除流中的重复元素。</p>
<p>例如：</p>
<p>​	打印所有作家的姓名，并且要求其中不能有重复元素。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">distinct</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(author <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(author.<span style="color:#a6e22e">getName</span>()));
</span></span></code></pre></div><p><strong>注意：distinct方法是依赖Object的equals方法来判断是否是相同对象的。所以需要注意重写equals方法。</strong></p>
<h5 id="sorted">sorted<a hidden class="anchor" aria-hidden="true" href="#sorted">#</a></h5>
<p>​	可以对流中的元素进行排序。</p>
<p>例如：</p>
<p>​	对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span><span style="color:#75715e">//        对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</span>
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">distinct</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">sorted</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(author <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(author.<span style="color:#a6e22e">getAge</span>()));
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span><span style="color:#75715e">//        对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</span>
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">distinct</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">sorted</span>((o1, o2) <span style="color:#f92672">-&gt;</span> o2.<span style="color:#a6e22e">getAge</span>()<span style="color:#f92672">-</span>o1.<span style="color:#a6e22e">getAge</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(author <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(author.<span style="color:#a6e22e">getAge</span>()));
</span></span></code></pre></div><p><strong>注意：如果调用空参的sorted()方法，需要流中的元素是实现了Comparable。</strong></p>
<p>​</p>
<h5 id="limit">limit<a hidden class="anchor" aria-hidden="true" href="#limit">#</a></h5>
<p>​	可以设置流的最大长度，超出的部分将被抛弃。</p>
<p>例如：</p>
<p>​	对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素,然后打印其中年龄最大的两个作家的姓名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">distinct</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">sorted</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">limit</span>(2)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(author <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(author.<span style="color:#a6e22e">getName</span>()));
</span></span></code></pre></div><h5 id="skip">skip<a hidden class="anchor" aria-hidden="true" href="#skip">#</a></h5>
<p>​	跳过流中的前n个元素，返回剩下的元素</p>
<p>例如：</p>
<p>​	打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">distinct</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">sorted</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">skip</span>(1)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(author <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(author.<span style="color:#a6e22e">getName</span>()));
</span></span></code></pre></div><h5 id="flatmap">flatMap<a hidden class="anchor" aria-hidden="true" href="#flatmap">#</a></h5>
<p>​	map只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象作为流中的元素。</p>
<p>例一：</p>
<p>​	打印所有书籍的名字。要求对重复的元素进行去重。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        打印所有书籍的名字。要求对重复的元素进行去重。</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">flatMap</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getBooks</span>().<span style="color:#a6e22e">stream</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">distinct</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(book <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(book.<span style="color:#a6e22e">getName</span>()));
</span></span></code></pre></div><p>例二：</p>
<p>​	打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情     爱情</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">flatMap</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getBooks</span>().<span style="color:#a6e22e">stream</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">distinct</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">flatMap</span>(book <span style="color:#f92672">-&gt;</span> Arrays.<span style="color:#a6e22e">stream</span>(book.<span style="color:#a6e22e">getCategory</span>().<span style="color:#a6e22e">split</span>(<span style="color:#e6db74">&#34;,&#34;</span>)))
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">distinct</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(category<span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(category));
</span></span></code></pre></div><h4 id="343-终结操作">3.4.3 终结操作<a hidden class="anchor" aria-hidden="true" href="#343-终结操作">#</a></h4>
<h5 id="foreach">forEach<a hidden class="anchor" aria-hidden="true" href="#foreach">#</a></h5>
<p>​	对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作。</p>
<p>例子：</p>
<p>​	输出所有作家的名字</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        输出所有作家的名字</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getName</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">distinct</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(name<span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(name));
</span></span></code></pre></div><h5 id="count">count<a hidden class="anchor" aria-hidden="true" href="#count">#</a></h5>
<p>​	可以用来获取当前流中元素的个数。</p>
<p>例子：</p>
<p>​	打印这些作家的所出书籍的数目，注意删除重复元素。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        打印这些作家的所出书籍的数目，注意删除重复元素。</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> count <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">flatMap</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getBooks</span>().<span style="color:#a6e22e">stream</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">distinct</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">count</span>();
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(count);
</span></span></code></pre></div><h5 id="maxmin">max&amp;min<a hidden class="anchor" aria-hidden="true" href="#maxmin">#</a></h5>
<p>​	可以用来或者流中的最值。</p>
<p>例子：</p>
<p>​	分别获取这些作家的所出书籍的最高分和最低分并打印。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        分别获取这些作家的所出书籍的最高分和最低分并打印。</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//Stream&lt;Author&gt;  -&gt; Stream&lt;Book&gt; -&gt;Stream&lt;Integer&gt;  -&gt;求值</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        Optional<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> max <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">flatMap</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getBooks</span>().<span style="color:#a6e22e">stream</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(book <span style="color:#f92672">-&gt;</span> book.<span style="color:#a6e22e">getScore</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">max</span>((score1, score2) <span style="color:#f92672">-&gt;</span> score1 <span style="color:#f92672">-</span> score2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Optional<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> min <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">flatMap</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getBooks</span>().<span style="color:#a6e22e">stream</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(book <span style="color:#f92672">-&gt;</span> book.<span style="color:#a6e22e">getScore</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">min</span>((score1, score2) <span style="color:#f92672">-&gt;</span> score1 <span style="color:#f92672">-</span> score2);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(max.<span style="color:#a6e22e">get</span>());
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(min.<span style="color:#a6e22e">get</span>());
</span></span></code></pre></div><h5 id="collect">collect<a hidden class="anchor" aria-hidden="true" href="#collect">#</a></h5>
<p>​	把当前流转换成一个集合。</p>
<p>例子：</p>
<p>​	获取一个存放所有作者名字的List集合。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        获取一个存放所有作者名字的List集合。</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> nameList <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getName</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">collect</span>(Collectors.<span style="color:#a6e22e">toList</span>());
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(nameList);
</span></span></code></pre></div><p>​	获取一个所有书名的Set集合。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        获取一个所有书名的Set集合。</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        Set<span style="color:#f92672">&lt;</span>Book<span style="color:#f92672">&gt;</span> books <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">flatMap</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getBooks</span>().<span style="color:#a6e22e">stream</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">collect</span>(Collectors.<span style="color:#a6e22e">toSet</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(books);
</span></span></code></pre></div><p>​	获取一个Map集合，map的key为作者名，value为List<Book></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        获取一个Map集合，map的key为作者名，value为List&lt;Book&gt;</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Map<span style="color:#f92672">&lt;</span>String, List<span style="color:#f92672">&lt;</span>Book<span style="color:#f92672">&gt;&gt;</span> map <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">distinct</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">collect</span>(Collectors.<span style="color:#a6e22e">toMap</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getName</span>(), author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getBooks</span>()));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(map);
</span></span></code></pre></div><h5 id="查找与匹配">查找与匹配<a hidden class="anchor" aria-hidden="true" href="#查找与匹配">#</a></h5>
<h6 id="anymatch">anyMatch<a hidden class="anchor" aria-hidden="true" href="#anymatch">#</a></h6>
<p>​	可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。</p>
<p>例子：</p>
<p>​	判断是否有年龄在29以上的作家</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        判断是否有年龄在29以上的作家</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">boolean</span> flag <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">anyMatch</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>() <span style="color:#f92672">&gt;</span> 29);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(flag);
</span></span></code></pre></div><h6 id="allmatch">allMatch<a hidden class="anchor" aria-hidden="true" href="#allmatch">#</a></h6>
<p>​	可以用来判断是否都符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。</p>
<p>例子：</p>
<p>​	判断是否所有的作家都是成年人</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        判断是否所有的作家都是成年人</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">boolean</span> flag <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">allMatch</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>() <span style="color:#f92672">&gt;=</span> 18);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(flag);
</span></span></code></pre></div><h6 id="nonematch">noneMatch<a hidden class="anchor" aria-hidden="true" href="#nonematch">#</a></h6>
<p>​	可以判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则结果为false</p>
<p>例子：</p>
<p>​	判断作家是否都没有超过100岁的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        判断作家是否都没有超过100岁的。</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">boolean</span> b <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">noneMatch</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>() <span style="color:#f92672">&gt;</span> 100);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(b);
</span></span></code></pre></div><h6 id="findany">findAny<a hidden class="anchor" aria-hidden="true" href="#findany">#</a></h6>
<p>​	获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。</p>
<p>例子：</p>
<p>​	获取任意一个年龄大于18的作家，如果存在就输出他的名字</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        获取任意一个年龄大于18的作家，如果存在就输出他的名字</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        Optional<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> optionalAuthor <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">filter</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>()<span style="color:#f92672">&gt;</span>18)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">findAny</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        optionalAuthor.<span style="color:#a6e22e">ifPresent</span>(author <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(author.<span style="color:#a6e22e">getName</span>()));
</span></span></code></pre></div><h6 id="findfirst">findFirst<a hidden class="anchor" aria-hidden="true" href="#findfirst">#</a></h6>
<p>​	获取流中的第一个元素。</p>
<p>例子：</p>
<p>​	获取一个年龄最小的作家，并输出他的姓名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        获取一个年龄最小的作家，并输出他的姓名。</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        Optional<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> first <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">sorted</span>((o1, o2) <span style="color:#f92672">-&gt;</span> o1.<span style="color:#a6e22e">getAge</span>() <span style="color:#f92672">-</span> o2.<span style="color:#a6e22e">getAge</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">findFirst</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        first.<span style="color:#a6e22e">ifPresent</span>(author <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(author.<span style="color:#a6e22e">getName</span>()));
</span></span></code></pre></div><h5 id="reduce归并">reduce归并<a hidden class="anchor" aria-hidden="true" href="#reduce归并">#</a></h5>
<p>​	对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作）</p>
<p>​	reduce的作用是把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。</p>
<p>​	reduce两个参数的重载形式内部的计算方式如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>T result <span style="color:#f92672">=</span> identity;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (T element : <span style="color:#66d9ef">this</span> stream)
</span></span><span style="display:flex;"><span>	result <span style="color:#f92672">=</span> accumulator.<span style="color:#a6e22e">apply</span>(result, element)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> result;
</span></span></code></pre></div><p>​	其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算也是我们通过方法参数来确定的。</p>
<p>例子：</p>
<p>​	使用reduce求所有作者年龄的和</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        使用reduce求所有作者年龄的和</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        Integer sum <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">distinct</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">reduce</span>(0, (result, element) <span style="color:#f92672">-&gt;</span> result <span style="color:#f92672">+</span> element);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(sum);
</span></span></code></pre></div><p>​	使用reduce求所有作者中年龄的最大值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        使用reduce求所有作者中年龄的最大值</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        Integer max <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">reduce</span>(Integer.<span style="color:#a6e22e">MIN_VALUE</span>, (result, element) <span style="color:#f92672">-&gt;</span> result <span style="color:#f92672">&lt;</span> element <span style="color:#f92672">?</span> element : result);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(max);
</span></span></code></pre></div><p>​	使用reduce求所有作者中年龄的最小值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        使用reduce求所有作者中年龄的最小值</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        Integer min <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">reduce</span>(Integer.<span style="color:#a6e22e">MAX_VALUE</span>, (result, element) <span style="color:#f92672">-&gt;</span> result <span style="color:#f92672">&gt;</span> element <span style="color:#f92672">?</span> element : result);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(min);
</span></span></code></pre></div><p>​	reduce一个参数的重载形式内部的计算</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span> 	 <span style="color:#66d9ef">boolean</span> foundAny <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>     T result <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">for</span> (T element : <span style="color:#66d9ef">this</span> stream) {
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>foundAny) {
</span></span><span style="display:flex;"><span>             foundAny <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>             result <span style="color:#f92672">=</span> element;
</span></span><span style="display:flex;"><span>         }
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>             result <span style="color:#f92672">=</span> accumulator.<span style="color:#a6e22e">apply</span>(result, element);
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> foundAny <span style="color:#f92672">?</span> Optional.<span style="color:#a6e22e">of</span>(result) : Optional.<span style="color:#a6e22e">empty</span>();
</span></span></code></pre></div><p>​	如果用一个参数的重载方法去求最小值代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        <span style="color:#75715e">//        使用reduce求所有作者中年龄的最小值</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        Optional<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> minOptional <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">reduce</span>((result, element) <span style="color:#f92672">-&gt;</span> result <span style="color:#f92672">&gt;</span> element <span style="color:#f92672">?</span> element : result);
</span></span><span style="display:flex;"><span>        minOptional.<span style="color:#a6e22e">ifPresent</span>(age<span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(age));
</span></span></code></pre></div><h3 id="35-注意事项">3.5 注意事项<a hidden class="anchor" aria-hidden="true" href="#35-注意事项">#</a></h3>
<ul>
<li>惰性求值（如果没有终结操作，没有中间操作是不会得到执行的）</li>
<li>流是一次性的（一旦一个流对象经过一个终结操作后。这个流就不能再被使用）</li>
<li>不会影响原数据（我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的）</li>
</ul>
<h2 id="4-optional">4. Optional<a hidden class="anchor" aria-hidden="true" href="#4-optional">#</a></h2>
<h3 id="41-概述">4.1 概述<a hidden class="anchor" aria-hidden="true" href="#41-概述">#</a></h3>
<p>​	我们在编写代码的时候出现最多的就是空指针异常。所以在很多情况下我们需要做各种非空的判断。</p>
<p>​	例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        Author author <span style="color:#f92672">=</span> getAuthor();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(author<span style="color:#f92672">!=</span><span style="color:#66d9ef">null</span>){
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(author.<span style="color:#a6e22e">getName</span>());
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><p>​	尤其是对象中的属性还是一个对象的情况下。这种判断会更多。</p>
<p>​	而过多的判断语句会让我们的代码显得臃肿不堪。</p>
<p>​	所以在JDK8中引入了Optional,养成使用Optional的习惯后你可以写出更优雅的代码来避免空指针异常。</p>
<p>​	并且在很多函数式编程相关的API中也都用到了Optional，如果不会使用Optional也会对函数式编程的学习造成影响。</p>
<h3 id="42-使用">4.2 使用<a hidden class="anchor" aria-hidden="true" href="#42-使用">#</a></h3>
<h4 id="421-创建对象">4.2.1 创建对象<a hidden class="anchor" aria-hidden="true" href="#421-创建对象">#</a></h4>
<p>​	Optional就好像是包装类，可以把我们的具体数据封装Optional对象内部。然后我们去使用Optional中封装好的方法操作封装进去的数据就可以非常优雅的避免空指针异常。</p>
<p>​	我们一般使用<strong>Optional</strong>的<strong>静态方法ofNullable</strong>来把数据封装成一个Optional对象。无论传入的参数是否为null都不会出现问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        Author author <span style="color:#f92672">=</span> getAuthor();
</span></span><span style="display:flex;"><span>        Optional<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authorOptional <span style="color:#f92672">=</span> Optional.<span style="color:#a6e22e">ofNullable</span>(author);
</span></span></code></pre></div><p>​	你可能会觉得还要加一行代码来封装数据比较麻烦。但是如果改造下getAuthor方法，让其的返回值就是封装好的Optional的话，我们在使用时就会方便很多。</p>
<p>​	而且在实际开发中我们的数据很多是从数据库获取的。Mybatis从3.5版本可以也已经支持Optional了。我们可以直接把dao方法的返回值类型定义成Optional类型，MyBastis会自己把数据封装成Optional对象返回。封装的过程也不需要我们自己操作。</p>
<p>​	如果你<strong>确定一个对象不是空</strong>的则可以使用<strong>Optional</strong>的<strong>静态方法of</strong>来把数据封装成Optional对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        Author author <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Author();
</span></span><span style="display:flex;"><span>        Optional<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authorOptional <span style="color:#f92672">=</span> Optional.<span style="color:#a6e22e">of</span>(author);
</span></span></code></pre></div><p>​	但是一定要注意，如果使用of的时候传入的参数必须不为null。（尝试下传入null会出现什么结果）</p>
<p>​	如果一个方法的返回值类型是Optional类型。而如果我们经判断发现某次计算得到的返回值为null，这个时候就需要把null封装成Optional对象返回。这时则可以使用<strong>Optional</strong>的<strong>静态方法empty</strong>来进行封装。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>		Optional.<span style="color:#a6e22e">empty</span>()
</span></span></code></pre></div><p>​</p>
<p>​	所以最后你觉得哪种方式会更方便呢？<strong>ofNullable</strong></p>
<h4 id="422-安全消费值">4.2.2 安全消费值<a hidden class="anchor" aria-hidden="true" href="#422-安全消费值">#</a></h4>
<p>​	我们获取到一个Optional对象后肯定需要对其中的数据进行使用。这时候我们可以使用其<strong>ifPresent</strong>方法对来消费其中的值。</p>
<p>​	这个方法会判断其内封装的数据是否为空，不为空时才会执行具体的消费代码。这样使用起来就更加安全了。</p>
<p>​	例如,以下写法就优雅的避免了空指针异常。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        Optional<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authorOptional <span style="color:#f92672">=</span> Optional.<span style="color:#a6e22e">ofNullable</span>(getAuthor());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        authorOptional.<span style="color:#a6e22e">ifPresent</span>(author <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(author.<span style="color:#a6e22e">getName</span>()));
</span></span></code></pre></div><h4 id="423-获取值">4.2.3 获取值<a hidden class="anchor" aria-hidden="true" href="#423-获取值">#</a></h4>
<p>​	如果我们想获取值自己进行处理可以使用get方法获取，但是不推荐。因为当Optional内部的数据为空的时候会出现异常。</p>
<h4 id="424-安全获取值">4.2.4 安全获取值<a hidden class="anchor" aria-hidden="true" href="#424-安全获取值">#</a></h4>
<p>​	如果我们期望安全的获取值。我们不推荐使用get方法，而是使用Optional提供的以下方法。</p>
<ul>
<li>
<p>orElseGet</p>
<p>获取数据并且设置数据为空时的默认值。如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建对象作为默认值返回。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        Optional<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authorOptional <span style="color:#f92672">=</span> Optional.<span style="color:#a6e22e">ofNullable</span>(getAuthor());
</span></span><span style="display:flex;"><span>        Author author1 <span style="color:#f92672">=</span> authorOptional.<span style="color:#a6e22e">orElseGet</span>(() <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">new</span> Author());
</span></span></code></pre></div></li>
<li>
<p>orElseThrow</p>
<p>获取数据，如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建异常抛出。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        Optional<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authorOptional <span style="color:#f92672">=</span> Optional.<span style="color:#a6e22e">ofNullable</span>(getAuthor());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            Author author <span style="color:#f92672">=</span> authorOptional.<span style="color:#a6e22e">orElseThrow</span>((Supplier<span style="color:#f92672">&lt;</span>Throwable<span style="color:#f92672">&gt;</span>) () <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">new</span> RuntimeException(<span style="color:#e6db74">&#34;author为空&#34;</span>));
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(author.<span style="color:#a6e22e">getName</span>());
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (Throwable throwable) {
</span></span><span style="display:flex;"><span>            throwable.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div></li>
</ul>
<h4 id="425-过滤">4.2.5 过滤<a hidden class="anchor" aria-hidden="true" href="#425-过滤">#</a></h4>
<p>​	我们可以使用filter方法对数据进行过滤。如果原本是有数据的，但是不符合判断，也会变成一个无数据的Optional对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        Optional<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authorOptional <span style="color:#f92672">=</span> Optional.<span style="color:#a6e22e">ofNullable</span>(getAuthor());
</span></span><span style="display:flex;"><span>        authorOptional.<span style="color:#a6e22e">filter</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>()<span style="color:#f92672">&gt;</span>100).<span style="color:#a6e22e">ifPresent</span>(author <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(author.<span style="color:#a6e22e">getName</span>()));
</span></span></code></pre></div><h4 id="426-判断">4.2.6 判断<a hidden class="anchor" aria-hidden="true" href="#426-判断">#</a></h4>
<p>​	我们可以使用isPresent方法进行是否存在数据的判断。如果为空返回值为false,如果不为空，返回值为true。但是这种方式并不能体现Optional的好处，<strong>更推荐使用ifPresent方法</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        Optional<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authorOptional <span style="color:#f92672">=</span> Optional.<span style="color:#a6e22e">ofNullable</span>(getAuthor());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (authorOptional.<span style="color:#a6e22e">isPresent</span>()) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(authorOptional.<span style="color:#a6e22e">get</span>().<span style="color:#a6e22e">getName</span>());
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><h4 id="427-数据转换">4.2.7 数据转换<a hidden class="anchor" aria-hidden="true" href="#427-数据转换">#</a></h4>
<p>​	Optional还提供了map可以让我们的对数据进行转换，并且转换得到的数据也还是被Optional包装好的，保证了我们的使用安全。</p>
<p>例如我们想获取作家的书籍集合。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testMap</span>() {
</span></span><span style="display:flex;"><span>        Optional<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authorOptional <span style="color:#f92672">=</span> getAuthorOptional();
</span></span><span style="display:flex;"><span>        Optional<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&lt;</span>Book<span style="color:#f92672">&gt;&gt;</span> optionalBooks <span style="color:#f92672">=</span> authorOptional.<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getBooks</span>());
</span></span><span style="display:flex;"><span>        optionalBooks.<span style="color:#a6e22e">ifPresent</span>(books <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(books));
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="5-函数式接口">5. 函数式接口<a hidden class="anchor" aria-hidden="true" href="#5-函数式接口">#</a></h2>
<h3 id="51-概述">5.1 概述<a hidden class="anchor" aria-hidden="true" href="#51-概述">#</a></h3>
<p>​	<strong>只有一个抽象方法</strong>的接口我们称之为函数接口。</p>
<p>​	JDK的函数式接口都加上了**@FunctionalInterface** 注解进行标识。但是无论是否加上该注解只要接口中只有一个抽象方法，都是函数式接口。</p>
<h3 id="52-常见函数式接口">5.2 常见函数式接口<a hidden class="anchor" aria-hidden="true" href="#52-常见函数式接口">#</a></h3>
<ul>
<li>
<p>​	Consumer 消费接口</p>
<p>根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数进行消费。</p>
<p><img loading="lazy" src="%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b.assets/image-20211028145622163-16354041894551.png" alt="image-20211028145622163"  />
</p>
</li>
<li>
<p>​	Function 计算转换接口</p>
<p>根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数计算或转换，把结果返回</p>
<p><img loading="lazy" src="%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b.assets/image-20211028145707862-16354042291112.png" alt="image-20211028145707862"  />
</p>
</li>
<li>
<p>​	Predicate 判断接口</p>
<p>根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数条件判断，返回判断结果</p>
<p><img loading="lazy" src="%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b.assets/image-20211028145818743-16354043004393.png" alt="image-20211028145818743"  />
</p>
</li>
<li>
<p>​	Supplier 生产型接口</p>
<p>根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中创建对象，把创建好的对象返回</p>
</li>
</ul>
<p><img loading="lazy" src="%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b.assets/image-20211028145843368-16354043246954.png" alt="image-20211028145843368"  />
</p>
<h3 id="53-常用的默认方法">5.3 常用的默认方法<a hidden class="anchor" aria-hidden="true" href="#53-常用的默认方法">#</a></h3>
<ul>
<li>
<p>and</p>
<p>我们在使用Predicate接口时候可能需要进行判断条件的拼接。而and方法相当于是使用&amp;&amp;来拼接两个判断条件</p>
<p>例如：</p>
<p>打印作家中年龄大于17并且姓名的长度大于1的作家。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        Stream<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authorStream <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>();
</span></span><span style="display:flex;"><span>        authorStream.<span style="color:#a6e22e">filter</span>(<span style="color:#66d9ef">new</span> Predicate<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">test</span>(Author author) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> author.<span style="color:#a6e22e">getAge</span>()<span style="color:#f92672">&gt;</span>17;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }.<span style="color:#a6e22e">and</span>(<span style="color:#66d9ef">new</span> Predicate<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">test</span>(Author author) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> author.<span style="color:#a6e22e">getName</span>().<span style="color:#a6e22e">length</span>()<span style="color:#f92672">&gt;</span>1;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        })).<span style="color:#a6e22e">forEach</span>(author <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(author));
</span></span></code></pre></div></li>
<li>
<p>or</p>
<p>我们在使用Predicate接口时候可能需要进行判断条件的拼接。而or方法相当于是使用||来拼接两个判断条件。</p>
<p>例如：</p>
<p>打印作家中年龄大于17或者姓名的长度小于2的作家。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        打印作家中年龄大于17或者姓名的长度小于2的作家。</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">filter</span>(<span style="color:#66d9ef">new</span> Predicate<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span>() {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">test</span>(Author author) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> author.<span style="color:#a6e22e">getAge</span>()<span style="color:#f92672">&gt;</span>17;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }.<span style="color:#a6e22e">or</span>(<span style="color:#66d9ef">new</span> Predicate<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span>() {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">test</span>(Author author) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> author.<span style="color:#a6e22e">getName</span>().<span style="color:#a6e22e">length</span>()<span style="color:#f92672">&lt;</span>2;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                })).<span style="color:#a6e22e">forEach</span>(author <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(author.<span style="color:#a6e22e">getName</span>()));
</span></span></code></pre></div></li>
<li>
<p>negate</p>
<p>Predicate接口中的方法。negate方法相当于是在判断添加前面加了个! 表示取反</p>
<p>例如：</p>
<p>打印作家中年龄不大于17的作家。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//        打印作家中年龄不大于17的作家。</span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">filter</span>(<span style="color:#66d9ef">new</span> Predicate<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span>() {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">test</span>(Author author) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span> author.<span style="color:#a6e22e">getAge</span>()<span style="color:#f92672">&gt;</span>17;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }.<span style="color:#a6e22e">negate</span>()).<span style="color:#a6e22e">forEach</span>(author <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(author.<span style="color:#a6e22e">getAge</span>()));
</span></span></code></pre></div></li>
</ul>
<h2 id="6-方法引用">6. 方法引用<a hidden class="anchor" aria-hidden="true" href="#6-方法引用">#</a></h2>
<p>​	我们在使用lambda时，如果方法体中只有一个方法的调用的话（包括构造方法）,我们可以用方法引用进一步简化代码。</p>
<h3 id="61-推荐用法">6.1 推荐用法<a hidden class="anchor" aria-hidden="true" href="#61-推荐用法">#</a></h3>
<p>​	我们在使用lambda时不需要考虑什么时候用方法引用，用哪种方法引用，方法引用的格式是什么。我们只需要在写完lambda方法发现方法体只有一行代码，并且是方法的调用时使用快捷键尝试是否能够转换成方法引用即可。</p>
<p>​	当我们方法引用使用的多了慢慢的也可以直接写出方法引用。</p>
<h3 id="62-基本格式">6.2 基本格式<a hidden class="anchor" aria-hidden="true" href="#62-基本格式">#</a></h3>
<p>​	类名或者对象名::方法名</p>
<h3 id="63-语法详解了解">6.3 语法详解(了解)<a hidden class="anchor" aria-hidden="true" href="#63-语法详解了解">#</a></h3>
<h4 id="631-引用类的静态方法">6.3.1 引用类的静态方法<a hidden class="anchor" aria-hidden="true" href="#631-引用类的静态方法">#</a></h4>
<p>​	其实就是引用类的静态方法</p>
<h5 id="格式">格式<a hidden class="anchor" aria-hidden="true" href="#格式">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>类名::方法名
</span></span></code></pre></div><h5 id="使用前提">使用前提<a hidden class="anchor" aria-hidden="true" href="#使用前提">#</a></h5>
<p>​	如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了某个类的静态方法</strong>，并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个静态方法中</strong>，这个时候我们就可以引用类的静态方法。</p>
<p>​</p>
<p>例如：</p>
<p>如下代码就可以用方法引用进行简化</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Stream<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authorStream <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        authorStream.<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(age<span style="color:#f92672">-&gt;</span>String.<span style="color:#a6e22e">valueOf</span>(age));
</span></span></code></pre></div><p>注意，如果我们所重写的方法是没有参数的，调用的方法也是没有参数的也相当于符合以上规则。</p>
<p>优化后如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Stream<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authorStream <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        authorStream.<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(String::valueOf);
</span></span></code></pre></div><h4 id="632-引用对象的实例方法">6.3.2 引用对象的实例方法<a hidden class="anchor" aria-hidden="true" href="#632-引用对象的实例方法">#</a></h4>
<h5 id="格式-1">格式<a hidden class="anchor" aria-hidden="true" href="#格式-1">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>对象名::方法名
</span></span></code></pre></div><h5 id="使用前提-1">使用前提<a hidden class="anchor" aria-hidden="true" href="#使用前提-1">#</a></h5>
<p>​	如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了某个对象的成员方法</strong>，并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个成员方法中</strong>，这个时候我们就可以引用对象的实例方法</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Stream<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authorStream <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>();
</span></span><span style="display:flex;"><span>        StringBuilder sb <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StringBuilder();
</span></span><span style="display:flex;"><span>        authorStream.<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getName</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(name<span style="color:#f92672">-&gt;</span>sb.<span style="color:#a6e22e">append</span>(name));
</span></span></code></pre></div><p>优化后：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Stream<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authorStream <span style="color:#f92672">=</span> authors.<span style="color:#a6e22e">stream</span>();
</span></span><span style="display:flex;"><span>        StringBuilder sb <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StringBuilder();
</span></span><span style="display:flex;"><span>        authorStream.<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getName</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(sb::append);
</span></span></code></pre></div><h4 id="634-引用类的实例方法">6.3.4 引用类的实例方法<a hidden class="anchor" aria-hidden="true" href="#634-引用类的实例方法">#</a></h4>
<h5 id="格式-2">格式<a hidden class="anchor" aria-hidden="true" href="#格式-2">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>类名::方法名
</span></span></code></pre></div><h5 id="使用前提-2">使用前提<a hidden class="anchor" aria-hidden="true" href="#使用前提-2">#</a></h5>
<p>​	如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了第一个参数的成员方法</strong>，并且我们把要<strong>重写的抽象方法中剩余的所有的参数都按照顺序传入了这个成员方法中</strong>，这个时候我们就可以引用类的实例方法。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">UseString</span>{
</span></span><span style="display:flex;"><span>        String <span style="color:#a6e22e">use</span>(String str,<span style="color:#66d9ef">int</span> start,<span style="color:#66d9ef">int</span> length);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> String <span style="color:#a6e22e">subAuthorName</span>(String str, UseString useString){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> length <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> useString.<span style="color:#a6e22e">use</span>(str,start,length);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        subAuthorName(<span style="color:#e6db74">&#34;三更草堂&#34;</span>, <span style="color:#66d9ef">new</span> UseString() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">use</span>(String str, <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> length) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> str.<span style="color:#a6e22e">substring</span>(start,length);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>优化后如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        subAuthorName(<span style="color:#e6db74">&#34;三更草堂&#34;</span>, String::substring);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h4 id="635-构造器引用">6.3.5 构造器引用<a hidden class="anchor" aria-hidden="true" href="#635-构造器引用">#</a></h4>
<p>​	如果方法体中的一行代码是构造器的话就可以使用构造器引用。</p>
<h5 id="格式-3">格式<a hidden class="anchor" aria-hidden="true" href="#格式-3">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>类名::<span style="color:#66d9ef">new</span>
</span></span></code></pre></div><h5 id="使用前提-3">使用前提<a hidden class="anchor" aria-hidden="true" href="#使用前提-3">#</a></h5>
<p>​	如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了某个类的构造方法</strong>，并且我们把<strong>要重写的抽象方法中的所有的参数都按照顺序传入了这个构造方法中</strong>，这个时候我们就可以引用构造器。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getName</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(name<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span> StringBuilder(name))
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(sb<span style="color:#f92672">-&gt;</span>sb.<span style="color:#a6e22e">append</span>(<span style="color:#e6db74">&#34;-三更&#34;</span>).<span style="color:#a6e22e">toString</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(str<span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(str));
</span></span></code></pre></div><p>优化后：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getName</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(StringBuilder::<span style="color:#66d9ef">new</span>)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(sb<span style="color:#f92672">-&gt;</span>sb.<span style="color:#a6e22e">append</span>(<span style="color:#e6db74">&#34;-三更&#34;</span>).<span style="color:#a6e22e">toString</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(str<span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(str));
</span></span></code></pre></div><h2 id="7-高级用法">7. 高级用法<a hidden class="anchor" aria-hidden="true" href="#7-高级用法">#</a></h2>
<h3 id="基本数据类型优化">基本数据类型优化<a hidden class="anchor" aria-hidden="true" href="#基本数据类型优化">#</a></h3>
<p>​	我们之前用到的很多Stream的方法由于都使用了泛型。所以涉及到的参数和返回值都是引用数据类型。</p>
<p>​	即使我们操作的是整数小数，但是实际用的都是他们的包装类。JDK5中引入的自动装箱和自动拆箱让我们在使用对应的包装类时就好像使用基本数据类型一样方便。但是你一定要知道装箱和拆箱肯定是要消耗时间的。虽然这个时间消耗很下。但是在大量的数据不断的重复装箱拆箱的时候，你就不能无视这个时间损耗了。</p>
<p>​	所以为了让我们能够对这部分的时间消耗进行优化。Stream还提供了很多专门针对基本数据类型的方法。</p>
<p>​	例如：mapToInt,mapToLong,mapToDouble,flatMapToInt,flatMapToDouble等。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test27</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(age <span style="color:#f92672">-&gt;</span> age <span style="color:#f92672">+</span> 10)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">filter</span>(age<span style="color:#f92672">-&gt;</span>age<span style="color:#f92672">&gt;</span>18)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(age<span style="color:#f92672">-&gt;</span>age<span style="color:#f92672">+</span>2)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(System.<span style="color:#a6e22e">out</span>::println);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">stream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">mapToInt</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(age <span style="color:#f92672">-&gt;</span> age <span style="color:#f92672">+</span> 10)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">filter</span>(age<span style="color:#f92672">-&gt;</span>age<span style="color:#f92672">&gt;</span>18)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(age<span style="color:#f92672">-&gt;</span>age<span style="color:#f92672">+</span>2)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(System.<span style="color:#a6e22e">out</span>::println);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="并行流">并行流<a hidden class="anchor" aria-hidden="true" href="#并行流">#</a></h3>
<p>​	当流中有大量元素时，我们可以使用并行流去提高操作的效率。其实并行流就是把任务分配给多个线程去完全。如果我们自己去用代码实现的话其实会非常的复杂，并且要求你对并发编程有足够的理解和认识。而如果我们使用Stream的话，我们只需要修改一个方法的调用就可以使用并行流来帮我们实现，从而提高效率。</p>
<p>​	parallel方法可以把串行流转换成并行流。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test28</span>() {
</span></span><span style="display:flex;"><span>        Stream<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> stream <span style="color:#f92672">=</span> Stream.<span style="color:#a6e22e">of</span>(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
</span></span><span style="display:flex;"><span>        Integer sum <span style="color:#f92672">=</span> stream.<span style="color:#a6e22e">parallel</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">peek</span>(<span style="color:#66d9ef">new</span> Consumer<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span>() {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">accept</span>(Integer num) {
</span></span><span style="display:flex;"><span>                        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(num<span style="color:#f92672">+</span>Thread.<span style="color:#a6e22e">currentThread</span>().<span style="color:#a6e22e">getName</span>());
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                })
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">filter</span>(num <span style="color:#f92672">-&gt;</span> num <span style="color:#f92672">&gt;</span> 5)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">reduce</span>((result, ele) <span style="color:#f92672">-&gt;</span> result <span style="color:#f92672">+</span> ele)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(sum);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>​	也可以通过parallelStream直接获取并行流对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>Author<span style="color:#f92672">&gt;</span> authors <span style="color:#f92672">=</span> getAuthors();
</span></span><span style="display:flex;"><span>        authors.<span style="color:#a6e22e">parallelStream</span>()
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(author <span style="color:#f92672">-&gt;</span> author.<span style="color:#a6e22e">getAge</span>())
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(age <span style="color:#f92672">-&gt;</span> age <span style="color:#f92672">+</span> 10)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">filter</span>(age<span style="color:#f92672">-&gt;</span>age<span style="color:#f92672">&gt;</span>18)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">map</span>(age<span style="color:#f92672">-&gt;</span>age<span style="color:#f92672">+</span>2)
</span></span><span style="display:flex;"><span>                .<span style="color:#a6e22e">forEach</span>(System.<span style="color:#a6e22e">out</span>::println);
</span></span></code></pre></div>

        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://XianCH.github.io/posts/tech/java/java%E9%9D%A2%E8%AF%95%E9%A2%98/">
    <span class="title">« 上一页</span>
    <br>
    <span>java面试题</span>
  </a>
  <a class="next" href="https://XianCH.github.io/posts/tech/distributed/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/">
    <span class="title">下一页 »</span>
    <br>
    <span>微服务保护</span>
  </a>
</nav>

        </footer>
    </div>






</article>
</main>

<footer class="footer">
    <span>
        Copyright
        &copy;
        -2024
        <a href="https://XianCH.github.io/" style="color:#939393;">X14n&#39;s Blog</a>
        All Rights Reserved
    </span>
    <a href="https://beian.miit.gov.cn/" target="_blank" style="color:#939393;"></a>&nbsp;
    <span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null"
           style="display:inline-block;text-decoration:none;height:20px;color:#939393;">
            <img src="" style="float:left;margin: 0px 5px 0px 0px;"/>
            
        </a>
    </span>
    <span id="busuanzi_container">
        <span class="fa fa-user"></span> <span id="busuanzi_value_site_uv"></span>
        <span class="fa fa-eye"></span> <span id="busuanzi_value_site_pv"></span>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"X14n's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"X14n's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '复制';

        function copyingDone() {
            copybutton.innerText = '已复制！';
            setTimeout(() => {
                copybutton.innerText = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"X14n's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        macTool.setAttribute('class', 'mac-tool')
        macTool1.setAttribute('class', 'mac bb1')
        macTool2.setAttribute('class', 'mac bb2')
        macTool3.setAttribute('class', 'mac bb3')
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>
</body>

</html>
